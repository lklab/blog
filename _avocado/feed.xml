<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-11T22:08:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lklab</title><subtitle>Reality and Theory</subtitle><author><name>khlee</name></author><entry><title type="html">Automated PLC Application Generation Solution from UPPAAL Model : UPPAAL2PLC</title><link href="http://localhost:4000/blog/UPPAAL2PLC/" rel="alternate" type="text/html" title="Automated PLC Application Generation Solution from UPPAAL Model : UPPAAL2PLC" /><published>2017-07-24T00:00:00+09:00</published><updated>2017-07-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/UPPAAL2PLC</id><content type="html" xml:base="http://localhost:4000/blog/UPPAAL2PLC/"><![CDATA[<h2 id="소개">소개</h2>

<p>개인적으로 개발 중인 UPPAAL2PLC의 1차 버전을 github에 릴리즈했다.</p>

<p>(repo : <a href="https://github.com/lklab/Uppaal2PLC">https://github.com/lklab/Uppaal2PLC</a>)</p>

<p>UPPAAL2PLC는 작년에 수업 프로젝트로 시작해서 개인적으로 계속 진행하고 있던 프로젝트로, 소프트웨어 모델링 및 검증 툴인 <a href="https://uppaal.org/">UPPAAL</a>을 통해 개발된 타임드 오토마타 모델을 PLC(Programmable Logic Controller)에서 동작하는 프로그램으로 자동 변환해주는 기능을 한다.</p>

<p>이 글에서는 UPPAAL2PLC를 포함하는 MDD(Model Driven-Development)의 개념과 UPPAAL2PLC를 사용하여 검증된 프로그램을 개발하는 예시를 다룰 것이다.</p>

<p>정형 기법(Formal Method)은 소프트웨어가 만족해야 하는 속성을 수학적인 증명을 통해 검증하는 방법이다. 이를 위해 검증이 가능하도록 수학적인 장치가 마련된 언어를 소프트웨어를 명세하는 데 사용하는데, 이것이 정형 언어(Formal Language)이다. 정형 언어로 기술된 소프트웨어는 비록 검증은 가능하더라도, 실제 프로그램으로 동작하기 위해서는 C나 자바 등의 개발 언어로 재작성 되어야 한다.</p>

<p>정형 언어와 개발 언어의 변환이 비정형적(informal)으로 이루어지면, 정형 기법을 통해 검증된 속성이 개발 언어에서도 만족한다는 보장을 할 수 없게 된다. 따라서 두 언어 사이의 변환을 자동화하는 방법으로 어느 정도 정형성을 확보하려는 노력을 하게 되는데, 이것이 바로 MDD다. 물론 완전한 정형적 보장을 위해서는 자동 변환 과정에 대한 검증도 필요하다.</p>

<p>UPPAAL2PLC는 정형 언어 타임드 오토마타(Timed Automata)로부터 C 코드로 변환 후 컴파일하여 PLC 응용으로 생성한다. 타임드 오토마타의 개발 및 검증 툴로 UPPAAL을 사용한다. 또한 PLC 플랫폼이나 응용이 입출력하는 데이터 등을 정의한 설정 파일도 별도 입력으로 받아, 생성된 코드나 응용에 대한 추가 작업 없이 바로 실행이 가능한 응용을 생성한다.</p>

<p>UPPAAL2PLC를 사용하여 PLC 응용을 개발하는 과정은 다음과 같다.</p>
<ol>
  <li>UPPAAL을 사용하여 타겟 시스템 모델링</li>
  <li>UPPAAL을 사용하여 모델 검증 및 모델 수정</li>
  <li>검증된 모델이 정의된 UPPAAL 프로젝트 파일과 설정 파일 준비</li>
  <li>UPPAAL2PLC에 두 파일 입력 후 실행하여 실행파일 생성</li>
</ol>

<p>이 과정에서 개발자가 직접 개입하는 과정은 1번, 3번이고, 나머지는 개발자가 명령을 내리면 UPPAAL 검증기(Verifier)나 UPPAAL2PLC가 자동으로 수행하는 것들이다.
UPPAAL2PLC는 타겟 시스템이 PLC로 한정되어 있는데, 이 때문에 개발자가 개입하는 1번, 3번 과정에서 지켜야 할 규칙이 있다. 이것을 다음 예시를 통해 설명할 것이다.</p>

<h2 id="예시---신호등-시스템">예시 - 신호등 시스템</h2>

<p>먼저 예시로 삼을 시스템을 정의한다. 간단하게 신호등 시스템이다. github에 올라와 있는 예제(<a href="https://github.com/lklab/Uppaal2PLC/tree/master/examples/TrafficLightControl">TrafficLightControl</a>)이기도 하다.
보행자는 버튼을 누를 수 있고 버튼이 눌리면 일정 시간 후에 초록 불이 된다. 그 후에는 버튼 입력과 상관 없이 일정 시간 후에 빨간 불이 되며, 다시 버튼을 누를 경우 그 시점부터 일정 시간 후에 초록 불이 된다.</p>

<h2 id="시스템-모델">시스템 모델</h2>

<p>먼저 UPPAAL을 사용해서 타겟 시스템을 모델링해야 한다. UPPAAL에서는 각 타임드 오토마타의 구조를 정의한 것을 템플릿이라고 하는데, 총 3종류의 템플릿으로 나누어서 모델링해야 한다. 그 종류는 시스템 모델, 환경 모델, 프로그램 모델이다. 시스템 모델은 PLC의 동작 방식을 모델링한 것으로 모든 응용에 대해 반드시 동일하게 포함해야 한다. 다음 그림은 시스템 모델을 나타낸다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/system_model.png" alt="System model" /></p>

<p>PLC는 주기적으로 동일한 로직을 반복 실행한다. 각 로직은 세 가지로 구분된다. 입력, 출력, 계산. 입력은 외부 장치로부터 값을 읽어서 메모리에 저장하는 것이고 출력은 메모리에 저장된 값을 외부 장치에 출력하는 것이다. 계산은 메모리에 저장된 입력 데이터로부터 응용마다 다르게 정의된 로직에 따라 계산된 출력 데이터를 메모리에 저장하는 것이다. 이러한 동작을 모델링한 것이 위의 시스템 모델이다. <code class="highlighter-rouge">tickClock</code>은 주기적인 실행을 모델링하기 위해 도입한 Clock 변수이고, <code class="highlighter-rouge">exchangeData()</code> 함수는 입력과 출력 기능을 수행하는 함수이다. <code class="highlighter-rouge">dataExchanged</code> 채널은 시스템 전체의 모델들에게 입출력 교환이 완료되었음을 알려서 계산을 수행하도록 신호를 주는 역할을 한다.</p>

<p><code class="highlighter-rouge">exchangeData()</code> 함수의 내용을 작성할 때에도 지켜야 할 규칙이 있다. 먼저 다음 그림을 보자.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/exchange_data.png" alt="Exchange data" /></p>

<p>함수 내에서는 앞 글자만 다른 두 변수의 값을 복사하는 것으로 이루어진다. 설명하자면, <code class="highlighter-rouge">p</code>로 시작하는 변수는 프로그램 모델쪽, <code class="highlighter-rouge">e</code>로 시작하는 변수는 환경 모델쪽 변수이다. 이렇게 같은 기능의 변수를 전역 변수 하나로 두어 공유하지 않고 분리하는 이유는 PLC의 동작 특성에 있다. 프로그램 모델은 PLC에서 동작하는 응용을 모델링한 것이고, 환경 모델은 외부 장치들을 모델링한 것이다. 이 예에서는 환경 모델에 신호등, 버튼, 보행자 등이 포함될 수 있을 것이다. PLC 시스템에서는 PLC와 외부 장치가 언제나 통신하여 데이터를 교환하는 것이 아니고 주기적인 시점에서만 데이터 교환이 일어난다. 따라서 전역 변수 하나를 공유하게 되면 이러한 특성이 드러나지 않게 되어, 모델과 실제 프로그램간 차이가 발생하며, 모델에서 검증된 속성이 실제 프로그램에서도 만족함을 보장할 수 없게 된다.</p>

<h2 id="환경-모델">환경 모델</h2>

<p>다음 그림들은 환경 모델이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_1.png" alt="Environment model 1" />
<img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_2.png" alt="Environment model 2" />
<img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_3.png" alt="Environment model 3" /></p>

<p>순서대로 보행자(Pedestrian), 신호등(Light), 버튼(Button) 모델인데, 자세한 내용은 설명하지 않고 동작 방식만 설명하려고 한다. 먼저 보행자 모델은 <code class="highlighter-rouge">push</code> 채널을 통해 버튼 모델에 신호를 보낼 수 있고 그 신호를 받으면 보튼 모델에서는 <code class="highlighter-rouge">eButton</code>, 즉 환경 모델 쪽 버튼 변수의 값을 <code class="highlighter-rouge">true</code>로 바꾼다. 이 값은 주기적인 시점, 즉 <code class="highlighter-rouge">exchangeData()</code> 함수가 호출될 때 프로그램 모델에 넘어갈 것이다. 신호등 모델은 주기적으로 <code class="highlighter-rouge">eLight</code>의 값을 확인하여 <code class="highlighter-rouge">true</code>이면 <code class="highlighter-rouge">Green</code>으로, <code class="highlighter-rouge">false</code>이면 <code class="highlighter-rouge">Red</code>로 상태를 변경한다.</p>

<h2 id="프로그램-모델">프로그램 모델</h2>

<p>이제 프로그램 모델이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/program_model.png" alt="Program model" /></p>

<p>프로그램 모델은 좀 복잡해 보이지만 간단히 말해서 아까 명세한 신호등의 기능을 모델링한 것이라고 보면 된다. 초기의 <code class="highlighter-rouge">LightRed</code> 상태에서 버튼 입력을 확인하고 <code class="highlighter-rouge">true</code>이면 <code class="highlighter-rouge">WAIT_TIME</code> 시간 동안 기다리다가 신호등 초록 불을 켜고(<code class="highlighter-rouge">pLight = true</code>), <code class="highlighter-rouge">GREEN_TIME</code> 시간 동안 기다리다가 다시 빨간 불로 돌아온다.(<code class="highlighter-rouge">pLight = false</code>)</p>

<p>실제로 응용으로 변환될 모델은 프로그램 모델이다. 환경 모델과 시스템 모델은 검증을 위해 필요한 모델들인데, 그렇다고 이들 모델링에 소홀하면 제대로 된 검증이 될 수 없다.
프로그램 모델 뿐만 아니라 환경 모델도 그 모델링 품질에 공을 들여야 한다.</p>

<h2 id="검증">검증</h2>

<p>두 번째 단계는 검증이다.
앞에서 환경 모델이 본래 기능 외에도 부가적으로 복잡하게 들어있는 이유는 바로 이 검증 때문이다. 단 여기서 주의할 게, 검증을 위해 부가적으로 들어간 것이 원래 모델의 동작에 영향이 있으면 안된다.</p>

<p>다음은 이번 예시에서의 검증 항목들이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/verification.png" alt="Verification" /></p>

<p>첫 번째는 일반적으로 데드락을 검증하는 것이다.
두 번째는 보행자의 응답성을 검증한 것인데 보행자 모델을 보면 <code class="highlighter-rouge">push</code> 채널을 통해 버튼 누름을 인지하면 <code class="highlighter-rouge">Waiting</code> 상태로 전이하면서 Clock <code class="highlighter-rouge">waiting_green_light</code>의 값을 <code class="highlighter-rouge">0</code>으로 초기화한다. 이후 신호등으로부터 초록 불 신호를 받으면 <code class="highlighter-rouge">Waiting</code> 상태를 벗어난다. 즉, <code class="highlighter-rouge">Waiting</code> 상태에서의 Clock <code class="highlighter-rouge">waiting_green_light</code>의 최댓값은 보행자 응답 시간의 최대를 나타내며 이 값이 <code class="highlighter-rouge">WAIT_TIME</code>에 2번의 주기 시간을 더한 값을 넘지 않음을 보인다.
세 번째 항목은 신호등이 빨간 불 상태에 진입했을 때 어떤 경우에도 최소한 이를 <code class="highlighter-rouge">WAIT_TIME</code> 시간 동안 유지함을 검증한 것이다. 이 역시 <code class="highlighter-rouge">Green</code> 상태로 전이할 때 초기화되는 Clock <code class="highlighter-rouge">keep_red_light</code>의 값을 통해 확인이 가능하다.</p>

<h2 id="설정-파일">설정 파일</h2>

<p>이로써 검증이 모두 완료되면 UPPAAL2PLC의 입력 파일 하나가 준비된 것이다. 남은 입력 파일인 설정 파일은 간단하다. 그냥 몇 가지 제시되어야 할 설정 값들을 형식에 맞게 입력하면 된다.
다음은 이번 예시에서 사용한 설정 파일의 내용이다.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;platform&gt;</span>
    <span class="nt">&lt;os&gt;</span>linux<span class="nt">&lt;/os&gt;</span>
    <span class="nt">&lt;protocol&gt;</span>soem<span class="nt">&lt;/protocol&gt;</span>
    <span class="nt">&lt;period&gt;</span>10000000<span class="nt">&lt;/period&gt;</span>
<span class="nt">&lt;/platform&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;task</span> <span class="na">type=</span><span class="s">"Controller"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;io</span> <span class="na">varname=</span><span class="s">"pButton"</span> <span class="na">address=</span><span class="s">"1:0x6000:0x1"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">direction=</span><span class="s">"in"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;io</span> <span class="na">varname=</span><span class="s">"pLight"</span> <span class="na">address=</span><span class="s">"1:0x7010:0x1"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">direction=</span><span class="s">"out"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/configuration&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">os</code>와 <code class="highlighter-rouge">protocol</code> 항목의 값은 각각 PLC의 운영체제와 통신 프로토콜의 종류를 나타낸다. 이 값에 따라 UPPAAL2PLC의 resources 디렉토리 아래에 있는 플랫폼 관련 코드들이 응용 생성시에 동적으로 선택되어 컴파일된다.
<code class="highlighter-rouge">period</code> 항목은 PLC 시스템의 제어 주기를 설정하는 것으로 ns 단위로 입력하면 된다.</p>

<p><code class="highlighter-rouge">task</code> 항목은 UPPAAL 프로젝트에 선언된 여러 템플릿들 중 프로그램 모델을 명시하는 것으로, 여기서는 프로그램 모델의 템플릿 이름인 <code class="highlighter-rouge">"Controller"</code>를 값으로 주었다. 아직 UPPAAL2PLC에서는 다중 태스크를 지원하지 않기 때문에 <code class="highlighter-rouge">task</code> 태그는 한 번만 선언 가능하다.
<code class="highlighter-rouge">io</code> 항목은 UPPAAL 모델에 선언된 변수를 실제 통신 변수에 매핑하기 위한 정보다. <code class="highlighter-rouge">varname</code>에는 UPPAAL 모델에 선언된 프로그램쪽 변수를 입력하면 되고, <code class="highlighter-rouge">address</code>에는 통신 변수를 특정하기 위해 통신 프로토콜별로 정의된 포맷에 따라 적으면 된다. 여기서는 SOEM 즉, EtherCAT을 사용하는데 이 프로토콜에서 <code class="highlighter-rouge">address</code>는 “:”으로 구분되는 각 세 파트에 [Slave 번호]:[OD Index]:[OD Subindex]를 적어넣으면 된다. 위 예시에서는 이들이 각각 스위치와 LED 장치를 나타낸다. <code class="highlighter-rouge">type</code>과 <code class="highlighter-rouge">direction</code>에는 각각 그 변수의 타입, 입출력 방향을 입력하면 된다.</p>

<h2 id="데모">데모</h2>

<p>이제 모든 입력 파일이 완성되었으니 UPPAAL2PLC를 실행하면 된다. github에 올린 프로젝트 내에는 위에서 언급한 모든 입력 파일이 준비되어 있으니, github에서 바로 다운받았다면, 명령어를 다음과 같이 입력하면 된다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./Uppaal2PLC.py examples/TrafficLightControl/TrafficLightControl.xml examples/TrafficLightControl/config.xml</code></pre></figure>

<p>이제 생성된 응용 “PlcApp”을 실행해 볼 차례다.
<a href="https://lklab.github.io/blog/blog/Raspberry-Pi-EtherCAT/">지난 번 글</a>에서처럼 라즈베리파이를 EtherCAT 마스터로, EL9800을 EtherCAT 슬레이브로 채택하였다.</p>

<iframe class="video" src="https://www.youtube.com/embed/4VELOOvaF1w" allowfullscreen="" frameborder="0"></iframe>]]></content><author><name>khlee</name></author><category term="MDD" /><summary type="html"><![CDATA[소개]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-24-UPPAAL2PLC/system_model.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-24-UPPAAL2PLC/system_model.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SOEM을 활용하여 라즈베리파이를 EtherCAT 마스터로 만들기</title><link href="http://localhost:4000/blog/Raspberry-Pi-EtherCAT/" rel="alternate" type="text/html" title="SOEM을 활용하여 라즈베리파이를 EtherCAT 마스터로 만들기" /><published>2017-07-17T00:00:00+09:00</published><updated>2017-07-17T00:00:00+09:00</updated><id>http://localhost:4000/blog/Raspberry-Pi-EtherCAT</id><content type="html" xml:base="http://localhost:4000/blog/Raspberry-Pi-EtherCAT/"><![CDATA[<p>라즈베리파이에 SOEM을 설치하여 EtherCAT 마스터로 동작하도록 할 것이다.
라즈베리파이는 B+ 모델을 사용했으며, OS로 2017년 03월 02일 버전 raspbian-jessie를 사용했다.</p>

<h2 id="준비하기">준비하기</h2>

<p>먼저 최신 버전의 SOEM을 다운로드 받는다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git clone https://github.com/OpenEtherCATsociety/SOEM</code></pre></figure>

<p><a href="http://openethercatsociety.github.io/">http://openethercatsociety.github.io/</a> 에서 받을 수 있는 1.3.1 버전에서는 make 기반으로 빌드가 가능했었는데, git에서 받은 버전은 cmake 기반으로 빌드를 한다.</p>

<p>사용하는 라즈베리파이에는 cmake가 설치되어있지 않으니 현재 최신 릴리즈 버전인 3.8.2 버전으로 설치했다. [<a href="https://cmake.org/install/">참고</a>]</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget https://cmake.org/files/v3.8/cmake-3.8.2.tar.gz
<span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xvzf</span> cmake-3.8.2.tar.gz
<span class="nv">$ </span><span class="nb">cd </span>cmake-3.8.2/
<span class="nv">$ </span>./bootstrap
<span class="nv">$ </span>make
<span class="nv">$ </span>make <span class="nb">install</span></code></pre></figure>

<p>라즈베리파이가 구닥다리라 엄청 오래 걸렸다..</p>

<p>이제 <a href="https://github.com/OpenEtherCATsociety/SOEM">README.md</a>에 나와있는 방법대로 SOEM 빌드를 한다!</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd </span>SOEM
<span class="nv">$ </span><span class="nb">mkdir </span>build
<span class="nv">$ </span><span class="nb">cd </span>build
<span class="nv">$ </span>cmake ..
<span class="nv">$ </span>make</code></pre></figure>

<p>빌드하고 나면 몇 가지 예제 프로그램이 생성되는데 그 중 SOEM/build/test/linux/simple_test/ 경로에 있는 simple_test라는 프로그램을 실행할 것이다.</p>

<p>그 전에 하드웨어 세팅을 시작하자.
구닥다리 라즈베리파이 B+에는 wifi가 기본 내장되어있지 않아서 ssh를 쓰기 위해 wifi 동글을 사용했다. 따라서 네트워크 인터페이스가 wlan0, eth0 두 개가 되는데, wlan0은 ssh를 포함한 인터넷을, eth0은 EtherCAT 포트로 사용한다.</p>

<p>EtherCAT 슬레이브로 사용할 장치는 Beckhoff사의 EL9800 보드로 하였다.
EtherCAT을 통해 제어 가능한 각 8개의 On-board LED와 스위치가 있다.</p>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" alt="Beckhoff EL9800" /></p>

<p>이제 예제 프로그램을 실행한다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd test</span>/linux/simple_test/
<span class="nv">$ </span>./simple_test eth0</code></pre></figure>

<p>실행시키면 다음 그림과 같이 PDO 값에 대해 모니터링해 준다.</p>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/pdo.png" alt="pdo" /></p>

<p><code class="highlighter-rouge">O:</code> 뒤에 첫 1바이트가 LED를 의미하고, <code class="highlighter-rouge">I:</code> 뒤의 첫 1바이트가 스위치를 의미한다.</p>

<h2 id="제어-프로그램-만들기">제어 프로그램 만들기</h2>

<p>그냥 실행만 시키면 재미없으니 LED에 불을 켜 보자!</p>

<p>SOEM/test/linux/simple_test/simple_test.c 파일을 열어서 PDO 교환을 수행하는 다음 코드를 보면</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* cyclic loop */</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ec_send_processdata</span><span class="p">();</span>
    <span class="n">wkc</span> <span class="o">=</span> <span class="n">ec_receive_processdata</span><span class="p">(</span><span class="n">EC_TIMEOUTRET</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">wkc</span> <span class="o">&gt;=</span> <span class="n">expectedWKC</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Processdata cycle %4d, WKC %d , O:"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">wkc</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oloop</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" %2.2x"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outputs</span> <span class="o">+</span> <span class="n">j</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">" I:"</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">iloop</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" %2.2x"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">j</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">" T:%"</span><span class="n">PRId64</span><span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">,</span><span class="n">ec_DCtime</span><span class="p">);</span>
        <span class="n">needlf</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">osal_usleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">ec_slave[0].outputs + offset</code>이 출력(마스터 -&gt; 슬레이브) PDO, 그러니까 RxPDO를 의미하고 <code class="highlighter-rouge">ec_slave[0].inputs + offset</code>이 TxPDO를 의미한다.</p>

<p>LED는 RxPDO의 첫 번째 바이트로 다음 변수를 통해 접근할 수 있다.</p>

<p><code class="highlighter-rouge">ec_slave[0].outputs + 0</code></p>

<p>정확한 내 장치의 SII에 저장된 PDO 목록을 보고싶다면 같이 빌드되는 예제 프로그램인 slaveinfo를 실행해보면 안다. 다음 명령어를 실행하면</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./slaveinfo eth0 <span class="nt">-map</span></code></pre></figure>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/slaveinfo.png" alt="pdo" /></p>

<p>슬레이브의 SII에 저장된 PDO 매핑 정보가 출력되어 나온다.</p>

<p>다시 LED를 제어하는 것으로 돌아와서!
위 코드의 <code class="highlighter-rouge">for</code> 블록문 첫 번째에 다음 코드를 넣었다.
물론 함수의 첫 부분에 int형 <code class="highlighter-rouge">ledval</code>(초기값 0x1)과 <code class="highlighter-rouge">tick</code> 변수(초기값 0x0)를 선언하였다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* cyclic loop */</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* for LED output test */</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">tick</span> <span class="o">%</span> <span class="mi">50</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">ledval</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ledval</span> <span class="o">&gt;=</span> <span class="mh">0x100</span><span class="p">)</span>
            <span class="n">ledval</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
        <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outputs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ledval</span><span class="p">;</span>
        <span class="n">tick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* for LED output test */</span>
    <span class="n">ec_send_processdata</span><span class="p">();</span>
    <span class="n">wkc</span> <span class="o">=</span> <span class="n">ec_receive_processdata</span><span class="p">(</span><span class="n">EC_TIMEOUTRET</span><span class="p">);</span></code></pre></figure>

<p>이제 다시 build 디렉토리로 돌아와서 빌드한다.
다시 빌드할 때에는 make만 하면 된다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ../../../build/
<span class="nv">$ </span>make</code></pre></figure>

<p>이제 실행시켜보면 된다.</p>

<iframe class="video" src="https://www.youtube.com/embed/CrT6T_HWt78" allowfullscreen="" frameborder="0"></iframe>]]></content><author><name>khlee</name></author><category term="EtherCAT" /><summary type="html"><![CDATA[라즈베리파이에 SOEM을 설치하여 EtherCAT 마스터로 동작하도록 할 것이다. 라즈베리파이는 B+ 모델을 사용했으며, OS로 2017년 03월 02일 버전 raspbian-jessie를 사용했다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>