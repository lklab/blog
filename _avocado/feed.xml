<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-18T23:55:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lklab</title><subtitle>Reality and Theory</subtitle><author><name>khlee</name></author><entry><title type="html">임베디드 환경에서 폰트 출력하기</title><link href="http://localhost:4000/blog/Font-Display/" rel="alternate" type="text/html" title="임베디드 환경에서 폰트 출력하기" /><published>2018-05-03T00:00:00+09:00</published><updated>2018-05-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/Font-Display</id><content type="html" xml:base="http://localhost:4000/blog/Font-Display/"><![CDATA[<p>디스플레이에 문자열을 픽셀 단위로 처리하여 출력하는 알고리즘을 개발하기 위해 먼저 각 문자별로 비트맵이 정의된 C 배열이 필요하다.</p>

<p>C 배열을 구하기 위해 열심히 구글링을 하던 중 굉장한 것을 찾았다.</p>

<p><a href="https://www.mikroe.com/glcd-font-creator">https://www.mikroe.com/glcd-font-creator</a></p>

<p>GLCD Font Creator라는 프로그램인데, 시스템에 정의된 폰트와 스타일, 크기를 설정하면 그에 맞는 C 배열을 생성해 준다.</p>

<p>생성된 C 배열의 구조는 다음과 같다.</p>

<p><img src="/blog/assets/post/18-05-03-Font-Display/20180504_121423.png" alt="generated c array" /></p>

<p>C 배열에서 각각의 줄은 줄 끝에 주석으로 설명된 문자에 해당하는 비트맵이고 순서는 아스키 코드를 따른다.</p>

<p>각각의 줄에서 가장 첫 번째 바이트는 개별 비트맵의 가로 픽셀 길이를 의미한다. 모든 문자의 비트맵은 가로, 세로가 고정된 고정길이로 정의되는데 (그림 예시에서는 7x15 픽셀), 가변길이로 출력하고 싶은 경우 첫 번째 바이트를 보고 비트맵의 특정 부분만 추려서 출력하면 된다.</p>

<p>나머지는 비트맵인데, 왼쪽 위부터 세로로 8비트씩 한 바이트이고 바이트 index는 수직 방향이 우선이다. 한 바이트의 8개 픽셀에서 가장 위쪽 픽셀이 LSB이고 아래쪽 픽셀이 MSB이다.</p>

<p>예를 들어 ‘a’ 문자의 경우 첫 번째 바이트인 0x06은 비트맵 중 폰트가 정의된 가로 픽셀 수를 의미하고 나머지는 다음과 같이 비트맵 데이터를 담고 있다.</p>

<p><img src="/blog/assets/post/18-05-03-Font-Display/20180504_134433.png" alt="generated c array: a character" /></p>

<p><img src="/blog/assets/post/18-05-03-Font-Display/bit_align.png" alt="bit align" /></p>

<p>따라서 byte 3의 경우 0x06이고 이 값이 배열의 5번째 바이트(index=4)에 존재하는 것을 알 수 있다.</p>

<p>비트맵이 정의된 C 배열을 얻었으니 이제 이 배열을 해석하여 특정 픽셀에 값을 써 주는 알고리즘을 개발하면 된다. 다음은 그 코드이다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define LCD_WIDTH 256
#define LCD_HEIGHT 64
</span>
<span class="kt">int</span> <span class="nf">draw_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_y</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">font</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">spacing</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line_spacing</span><span class="p">,</span> <span class="kt">int</span> <span class="n">monospace</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">,</span> <span class="n">char_x</span><span class="p">,</span> <span class="n">char_y</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">height_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">entry_size</span> <span class="o">=</span> <span class="n">height_byte</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bitmap_width</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit_index</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">;</span>

    <span class="n">char_x</span> <span class="o">=</span> <span class="n">base_x</span><span class="p">;</span>
    <span class="n">char_y</span> <span class="o">=</span> <span class="n">base_y</span><span class="p">;</span>
    <span class="n">cur_x</span> <span class="o">=</span> <span class="n">char_x</span><span class="p">;</span>
    <span class="n">cur_y</span> <span class="o">=</span> <span class="n">char_y</span><span class="p">;</span>

    <span class="k">if</span><span class="p">((</span><span class="n">cur_y</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">LCD_HEIGHT</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* out of LCD size */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">spacing</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* invalid argument */</span>

    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* new line character */</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">char_x</span> <span class="o">=</span> <span class="n">base_x</span><span class="p">;</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">char_x</span><span class="p">;</span>
            <span class="n">char_y</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">+</span> <span class="n">line_spacing</span><span class="p">;</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="n">char_y</span><span class="p">;</span>
            <span class="n">string</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">||</span> <span class="o">*</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">string</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span> <span class="cm">/* invalid character */</span>
        <span class="p">}</span>

        <span class="cm">/* get character data */</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">monospace</span><span class="p">)</span>
            <span class="n">bitmap_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">bitmap_width</span> <span class="o">=</span> <span class="n">font</span><span class="p">[</span><span class="n">entry_size</span> <span class="o">*</span> <span class="n">index</span><span class="p">];</span>
        <span class="n">bitmap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">font</span><span class="p">[</span><span class="n">entry_size</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">char_x</span> <span class="o">+</span> <span class="n">bitmap_width</span> <span class="o">&gt;</span> <span class="n">LCD_WIDTH</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* out of LCD size */</span>

        <span class="cm">/* draw character */</span>
        <span class="k">for</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bitmap_width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height_byte</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">height_byte</span> <span class="o">+</span> <span class="n">y</span><span class="p">];</span>

                <span class="k">for</span><span class="p">(</span><span class="n">bit_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit_index</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">bit_index</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">((</span><span class="n">y</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">bit_index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span> <span class="cm">/* skip unused bits */</span>

                    <span class="n">bit</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
                    <span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="cm">/*
                     * TODO: Implement draw_pixel() function
                     * for your target system.
                     */</span>
                    <span class="n">draw_pixel</span><span class="p">(</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
                    <span class="n">cur_y</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">cur_x</span><span class="o">++</span><span class="p">;</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="n">char_y</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* process the next character */</span>
        <span class="n">char_x</span> <span class="o">+=</span> <span class="n">bitmap_width</span> <span class="o">+</span> <span class="n">spacing</span><span class="p">;</span>
        <span class="n">cur_x</span> <span class="o">=</span> <span class="n">char_x</span><span class="p">;</span>
        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>이 코드를 사용하기 위해서는 다음을 수정해야 한다.</p>

<ol>
  <li><code class="highlighter-rouge">LCD_WIDTH</code>와 <code class="highlighter-rouge">LCD_HEIGHT</code>를 타겟 디스플레이의 가로/세로 픽셀 길이로 정의</li>
  <li><code class="highlighter-rouge">draw_pixel()</code> 함수를 각자 타겟 디스플레이에 맞는 코드로 구현</li>
</ol>

<p><code class="highlighter-rouge">int draw_pixel(x, y, bit)</code> 함수는 디스플레이의 왼쪽 위를 (0, 0) 좌표로 정의했을 때 (x, y) 위치에 해당하는 픽셀을 bit 값으로 설정하는 함수이다. bit는 0 또는 1이 입력된다.</p>

<p>이 코드의 파라미터에 대한 설명은 다음과 같다.</p>

<ol>
  <li><code class="highlighter-rouge">string</code>: 출력할 문자열 (<code class="highlighter-rouge">'\0'</code> 문자로 끝나는)</li>
  <li><code class="highlighter-rouge">base_x</code>: 문자열의 왼쪽 위 점이 위치할 디스플레이 상의 x 좌표</li>
  <li><code class="highlighter-rouge">base_y</code>: 문자열의 왼쪽 위 점이 위치할 디스플레이 상의 y 좌표</li>
  <li><code class="highlighter-rouge">font</code>: 앞에서 GLCD font creator를 통해 생성한 C 배열</li>
  <li><code class="highlighter-rouge">width</code>: 폰트의 가로 픽셀 길이</li>
  <li><code class="highlighter-rouge">height</code>: 폰트의 세로 픽셀 길이</li>
  <li><code class="highlighter-rouge">start</code> 폰트에 정의된 시작 문자의 아스키 코드</li>
  <li><code class="highlighter-rouge">end</code>: 폰트에 정의된 끝 문자의 아스키 코드</li>
  <li><code class="highlighter-rouge">spacing</code>: 자간</li>
  <li><code class="highlighter-rouge">line_spacing</code>: 줄 간격</li>
  <li><code class="highlighter-rouge">monospace</code>: 1이면 고정길이 출력 0이면 가변길이 출력</li>
</ol>

<p>파라미터가 많은데, 기존 코드에서는 구조체를 통해 함수를 호출하도록 하였으나 설명을 위해 하나하나 풀어서 작성하였다.</p>

<p><code class="highlighter-rouge">width</code>, <code class="highlighter-rouge">height</code>는 폰트의 가로 및 세로 픽셀 수이다. GLCD font creator에서 생성하는 C 배열은 가변길이 폰트라도 크기가 가장 큰 문자를 기준으로 가로 및 세로 픽셀 수가 모든 문자에 대해 고정으로 정의된다. (빈 부분의 픽셀 값은 0)</p>

<p><code class="highlighter-rouge">start</code>, <code class="highlighter-rouge">end</code>의 경우 GLCD font creator에서 C 배열을 생성할 때 메모리 절약을 위해 사용하지 않는 아스키 코드 구간을 삭제하고 비트맵을 생성하도록 설정할 수 있는데, 여기서 생성하도록 설정된 아스키 코드 구간의 첫 문자가 <code class="highlighter-rouge">start</code>이고, 마지막 문자가 <code class="highlighter-rouge">end</code>이다.<br />
기본 설정의 경우 32 ~ 127 구간의 C 배열을 생성하므로 <code class="highlighter-rouge">start=32</code>, <code class="highlighter-rouge">end=127</code>을 지정하면 된다.</p>

<p><code class="highlighter-rouge">spacing</code>, <code class="highlighter-rouge">line_spacing</code>: 자간과 줄간격도 설정할 수 있도록 구현하였다.<br />
<code class="highlighter-rouge">monospace</code>: 가변길이 문자열을 고정길이로 출력할 경우 어색하기 때문에 <code class="highlighter-rouge">monospace</code> 파라미터를 사용하여 어떤 방식으로 출력할지 설정하도록 하였다.</p>

<p>위 함수의 사용 예는 다음과 같다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">draw_string</span><span class="p">(</span><span class="s">"Hello</span><span class="se">\n</span><span class="s">World!"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">consolas7x15</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>]]></content><author><name>khlee</name></author><category term="Embedded" /><summary type="html"><![CDATA[디스플레이에 문자열을 픽셀 단위로 처리하여 출력하는 알고리즘을 개발하기 위해 먼저 각 문자별로 비트맵이 정의된 C 배열이 필요하다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/18-05-03-Font-Display/oled.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/18-05-03-Font-Display/oled.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">IgH EtherCAT Master Stack API 분석</title><link href="http://localhost:4000/blog/IgH-EtherCAT/" rel="alternate" type="text/html" title="IgH EtherCAT Master Stack API 분석" /><published>2018-02-14T00:00:00+09:00</published><updated>2018-02-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/IgH-EtherCAT</id><content type="html" xml:base="http://localhost:4000/blog/IgH-EtherCAT/"><![CDATA[<h2 id="준비물">준비물</h2>

<ul>
  <li>IgH EtherCAT Master Stack 1.5.2와 Xenomai OS가 설치된 제어기</li>
  <li>위 플랫폼에 대한 개발환경 (툴체인, 라이브러리 등)</li>
  <li>Digital I/O EtherCAT Slave 장치</li>
</ul>

<h2 id="참고자료">참고자료</h2>

<ul>
  <li><a href="https://etherlab.org/en/ethercat/">IgH EtherCAT Master Stack 라이브러리</a></li>
  <li><a href="https://etherlab.org/download/ethercat/ethercat-1.5.2.pdf">IgH EtherCAT Master Stack 1.5.2 Documentation</a></li>
</ul>

<h2 id="예제코드">예제코드</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;native/task.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;native/timer.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ecrt.h&gt;</span><span class="cp">
</span>
<span class="cp">#define INTERVAL 1000000
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt_task_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sigint_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>

<span class="cm">/* PDO list to use in application */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave0_6000_01</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave0_6000_01_bit</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave0_7010_01</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave0_7010_01_bit</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ec_pdo_entry_reg_t</span> <span class="n">pdo_entry_reg</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x6000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_6000_01</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_6000_01_bit</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x7010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_7010_01</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_7010_01_bit</span><span class="p">},</span>
    <span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ec_master_t</span><span class="o">*</span> <span class="n">master</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="n">ec_domain_t</span><span class="o">*</span> <span class="n">domain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">domain_pd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">alive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">ec_master_info_t</span> <span class="n">master_info</span><span class="p">;</span>
    <span class="n">ec_slave_info_t</span><span class="o">*</span> <span class="n">slave_info_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ec_slave_config_t</span><span class="o">*</span> <span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">slave_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">RT_TASK</span><span class="o">*</span> <span class="n">rt_task_plc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* signal handler registration */</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sigint_handler</span><span class="p">);</span>

    <span class="cm">/* configure master */</span>
    <span class="n">master</span> <span class="o">=</span> <span class="n">ecrt_request_master</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">master</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT master request failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">ecrt_master_create_domain</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">domain</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT domain creation failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">ecrt_master</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master_info</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT master information request failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* allocate momory for slave information */</span>
    <span class="n">slave_count</span> <span class="o">=</span> <span class="n">master_info</span><span class="p">.</span><span class="n">slave_count</span><span class="p">;</span>
    <span class="n">slave_info_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec_slave_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ec_slave_info_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">slave_count</span><span class="p">);</span>

    <span class="cm">/* configure slaves */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slave_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ecrt_master_get_slave</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT slave information request failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">slave</span> <span class="o">=</span> <span class="n">ecrt_master_slave_config</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor_id</span><span class="p">,</span>
            <span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">product_code</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT slave configuration failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* setup PDO registration array */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">slave_count</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor_id</span> <span class="o">=</span>
                <span class="n">slave_info_list</span><span class="p">[</span><span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">].</span><span class="n">vendor_id</span><span class="p">;</span>
            <span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">product_code</span> <span class="o">=</span>
                <span class="n">slave_info_list</span><span class="p">[</span><span class="n">pdo_entry_reg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">].</span><span class="n">product_code</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* get PDO entry list */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ecrt_domain_reg_pdo_entry_list</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdo_entry_reg</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT PDO registration failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* create real-time periodic task */</span>
    <span class="n">rt_task_plc</span> <span class="o">=</span> <span class="p">(</span><span class="n">RT_TASK</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">RT_TASK</span><span class="p">));</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rt_task_create</span><span class="p">(</span><span class="n">rt_task_plc</span><span class="p">,</span> <span class="s">"rt_task_plc"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">T_JOINABLE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Real-time task creation failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* activate EtherCAT master */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ecrt_master_set_send_interval</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">INTERVAL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT setting send interval failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">ecrt_master_activate</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT master activation failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* get PDO domain pointer */</span>
    <span class="n">domain_pd</span> <span class="o">=</span> <span class="n">ecrt_domain_data</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">domain_pd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EtherCAT mapping process data failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* start real-time periodic task */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rt_task_start</span><span class="p">(</span><span class="n">rt_task_plc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_task_proc</span><span class="p">,</span> <span class="n">rt_task_plc</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Real-time task start failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rt_task_join</span><span class="p">(</span><span class="n">rt_task_plc</span><span class="p">);</span>

<span class="n">CLEANUP</span> <span class="o">:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">slave_info_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">free</span><span class="p">(</span><span class="n">slave_info_list</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rt_task_plc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">free</span><span class="p">(</span><span class="n">rt_task_plc</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">master</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">ecrt_release_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt_task_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sw</span><span class="p">,</span> <span class="n">led</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">RT_TASK</span><span class="o">*</span> <span class="n">rt_task_plc</span> <span class="o">=</span> <span class="p">(</span><span class="n">RT_TASK</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="n">RTIME</span> <span class="n">current_time</span> <span class="o">=</span> <span class="n">rt_timer_read</span><span class="p">();</span>

    <span class="cm">/* set real-time task timer */</span>
    <span class="n">rt_task_set_periodic</span><span class="p">(</span><span class="n">rt_task_plc</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">+</span> <span class="n">INTERVAL</span><span class="p">,</span>
        <span class="n">rt_timer_ns2ticks</span><span class="p">(</span><span class="n">INTERVAL</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="n">alive</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* retrieve */</span>
        <span class="n">ecrt_master_receive</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
        <span class="n">ecrt_domain_process</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">EC_READ_BIT</span><span class="p">(</span><span class="n">domain_pd</span> <span class="o">+</span> <span class="n">slave0_6000_01</span><span class="p">,</span> <span class="n">slave0_6000_01_bit</span><span class="p">);</span>

        <span class="cm">/* computation */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sw</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">led</span> <span class="o">=</span> <span class="o">!</span><span class="n">led</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">led</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* publish */</span>
        <span class="n">EC_WRITE_BIT</span><span class="p">(</span><span class="n">domain_pd</span> <span class="o">+</span> <span class="n">slave0_7010_01</span><span class="p">,</span> <span class="n">slave0_7010_01_bit</span><span class="p">,</span> <span class="n">led</span><span class="p">);</span>        <span class="n">ecrt_domain_queue</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
        <span class="n">ecrt_master_send</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

        <span class="cm">/* wait until next period */</span>
        <span class="n">rt_task_wait_period</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sigint_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">alive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="설명">설명</h2>

<p>본 예제 코드는 slave 장치의 스위치가 on 상태인 경우 LED를 1Hz로 깜빡이게 하는 응용이다.<br />
IgH와 같은 역할을 하는 SOEM을 활용한 마스터 예제 코드와 비교해서 IgH가 더 성능도 좋고 기능도 많기 때문인지 예제 코드의 양이 많은 편이다.</p>

<h2 id="마스터-초기화">마스터 초기화</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">master</span> <span class="o">=</span> <span class="n">ecrt_request_master</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">ecrt_master_create_domain</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="n">ecrt_master</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master_info</span><span class="p">);</span>
<span class="n">slave_count</span> <span class="o">=</span> <span class="n">master_info</span><span class="p">.</span><span class="n">slave_count</span><span class="p">;</span></code></pre></figure>

<p>마스터 초기화는 현재 프로그램이 실행되고 있는 마스터 장치에서 0번 EtherCAT 인터페이스에 대한 오브젝트<code class="highlighter-rouge">master</code>를 받아온 후 그에 대한 도메인 오브젝트<code class="highlighter-rouge">domain</code>을 받는 것으로 이루어진다. 마스터 오브젝트<code class="highlighter-rouge">master</code>가 마스터 장치를 의미한다면, 도메인<code class="highlighter-rouge">domain</code>은 주기적으로 통신할 데이터(PDO)들을 의미한다.<br />
마스터 오브젝트의 필드는 IgH 라이브러리 내에서만 접근할 수 있도록 감추어져 있기 때문에 슬레이브 장치의 수 등 정보를 알기 위해서는 <code class="highlighter-rouge">ecrt_master()</code>로 마스터 오브젝트의 정보를 받아와야 한다. 슬레이브 장치의 수는 <code class="highlighter-rouge">master_info.slave_count</code>를 통해 알 수 있다.</p>

<h2 id="슬레이브-초기화">슬레이브 초기화</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slave_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ecrt_master_get_slave</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">ecrt_master_slave_config</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor_id</span><span class="p">,</span>
        <span class="n">slave_info_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">product_code</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>슬레이브 초기화를 위한 함수 <code class="highlighter-rouge">ecrt_master_slave_config()</code>는 초기화하려는 슬레이브의 Vendor ID와 Product code를 필요로 한다. 해당 정보는 <code class="highlighter-rouge">ecrt_master_get_slave()</code> 함수로 얻어올 수 있다.<br />
본 예제와 같이 슬레이브로부터 필요한 정보를 받아와서 초기화를 하는 방법이 있고 마스터에서 미리 설정된 정보를 이용하여 직접 초기화 하는 방법이 있다. 전자의 경우 슬레이브 내에 설정 정보들이 저장되어 있는 SII(Slave Information Interface)로부터 마스터가 초기화에 필요한 정보를 읽어 초기화가 이루어지며, 후자의 경우 사용자가 특정 슬레이브의 정보가 XML 포맷으로 정의된 ESI 파일을 마스터 프로그램(예를 들어 TwinCAT과 같은 프로그램)을 통해 입력하여 초기화가 이루어진다.</p>

<h2 id="입출력pdo-설정">입출력(PDO) 설정</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">ec_pdo_entry_reg_t</span> <span class="n">pdo_entry_reg</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x6000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_6000_01</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_6000_01_bit</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x7010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_7010_01</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave0_7010_01_bit</span><span class="p">},</span>
    <span class="p">{}</span>
<span class="p">};</span>
<span class="n">ecrt_domain_reg_pdo_entry_list</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdo_entry_reg</span><span class="p">);</span></code></pre></figure>

<p>주기적으로 통신할 데이터를 정의하는 입출력 설정으로는 <code class="highlighter-rouge">ec_pdo_entry_reg_t</code> 타입의 구조체와 <code class="highlighter-rouge">ecrt_domain_reg_pdo_entry_list()</code> 함수가 사용된다. <code class="highlighter-rouge">ec_pdo_entry_reg_t</code> 구조체는 ecrt.h 파일에 다음과 같이 정의되어 있다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">alias</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">vendor_id</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">product_code</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">subindex</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bit_position</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ec_pdo_entry_reg_t</span><span class="p">;</span></code></pre></figure>

<p>alias와 position을 통해 어떤 슬레이브 장치인지 특정한다. <code class="highlighter-rouge">vendor_id</code>와 <code class="highlighter-rouge">product_code</code>는 특정한 슬레이브에 대한 정보로, 해당 슬레이브의 정보와 일치해야 한다. 예제 코드에서는 <code class="highlighter-rouge">ecrt_master_get_slave()</code> 함수를 통해 얻은 정보를 이용하여 이 값을 초기화하는 코드가 있다. <code class="highlighter-rouge">index</code>와 <code class="highlighter-rouge">subindex</code>는 특정한 슬레이브 장치에서 통신할 OD(Object Dictionary)의 index와 subindex를 의미한다. 이와 같은 정보를 입력한 구조체의 배열을 정의한 후 <code class="highlighter-rouge">ecrt_domain_reg_pdo_entry_list()</code> 함수를 호출하면 해당 구조체의 마지막 두 필드에 PDO 엔트리의 byte offset과 bit position이 저장된다. 이 값은 추후에 입출력을 위해 사용된다.</p>

<h2 id="마스터-활성화">마스터 활성화</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">ecrt_master_set_send_interval</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">INTERVAL</span><span class="p">);</span>
<span class="n">ecrt_master_activate</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="n">domain_pd</span> <span class="o">=</span> <span class="n">ecrt_domain_data</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span></code></pre></figure>

<p>마스터가 통신할 주기를 설정하고 활성화한다. 통신할 주기는 <code class="highlighter-rouge">ecrt_master_set_send_interval()</code> 함수를 통해 설정할 수 있으며, 두 번째 인자에 주기를 나노초 단위로 입력하면 된다. 이후에 <code class="highlighter-rouge">ecrt_master_activate()</code> 함수를 통해 마스터 장치를 활성화한다. 활성화 이후에는 실시간 context로 전환되며 <code class="highlighter-rouge">malloc()</code>이나 대부분의 IgH 라이브러리 함수들을 포함하는 비실시간 함수들의 사용은 제한된다. 이 함수가 호출된 이후에는 실시간 함수들만 사용할 수 있다.<br />
<code class="highlighter-rouge">ecrt_domain_data()</code> 함수는 인자로 전달된 도메인에 대한 데이터 필드의 포인터를 받아온다. 이 값도 추후에 입출력을 위해 사용된다.</p>

<h2 id="실행-단계">실행 단계</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">while</span><span class="p">(</span><span class="n">alive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* retrieve */</span>
    <span class="n">ecrt_master_receive</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
    <span class="n">ecrt_domain_process</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="n">sw</span> <span class="o">=</span> <span class="n">EC_READ_BIT</span><span class="p">(</span><span class="n">domain_pd</span> <span class="o">+</span> <span class="n">slave0_6000_01</span><span class="p">,</span> <span class="n">slave0_6000_01_bit</span><span class="p">);</span>

    <span class="cm">/* computation */</span>
    <span class="cm">/* write some computation code... */</span>

    <span class="cm">/* publish */</span>
    <span class="n">EC_WRITE_BIT</span><span class="p">(</span><span class="n">domain_pd</span> <span class="o">+</span> <span class="n">slave0_7010_01</span><span class="p">,</span> <span class="n">slave0_7010_01_bit</span><span class="p">,</span> <span class="n">led</span><span class="p">);</span>
    <span class="n">ecrt_domain_queue</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="n">ecrt_master_send</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

    <span class="cm">/* wait until next period */</span>
<span class="p">}</span></code></pre></figure>

<p>실행 단계에서는 <code class="highlighter-rouge">ecrt_master_set_send_interval()</code> 함수를 통해 설정한 주기마다 [retrieve] - [computation] - [publish]를 반복한다.<br />
retrieve에서는 <code class="highlighter-rouge">ecrt_mater_receive()</code> 함수와 <code class="highlighter-rouge">ecrt_domain_process()</code> 함수가 기본적으로 필요하며, 앞서 입출력 설정에서 입력으로 설정한 데이터를 슬레이브로부터 받아오는 것으로 구성된다. 데이터를 받아오는 기능은 ecrt.h에 매크로로 정의되어 있으며 데이터의 타입별로 매크로가 따로 정의되어 있다. (<code class="highlighter-rouge">EC_READ_BIT</code> 등) 이 매크로를 사용할 때 마스터 활성화 단계에서 얻은 도메인 데이터 필드의 포인터(<code class="highlighter-rouge">domain_pd</code>)와 함께 입출력 설정에서 <code class="highlighter-rouge">ecrt_domain_reg_pdo_entry_list()</code> 함수를 통해 얻은 byte offset과 bit position이 사용된다.<br />
computation에서는 retrieve에서 읽어오는 데이터를 토대로 publish에서 쓸 데이터를 계산한다. 이 위치의 코드는 응용에 따라 자유롭게 구성된다.<br />
publish에서는 retrieve와 반대로 먼저 <code class="highlighter-rouge">EC_WRITE_BIT</code> 등의 매크로로 도메인 데이터 필드에 값을 쓴 다음 <code class="highlighter-rouge">ecrt_domain_queue()</code> 함수와 <code class="highlighter-rouge">ecrt_master_send()</code> 함수를 통해 그 값을 슬레이브로 출력한다.</p>]]></content><author><name>khlee</name></author><category term="EtherCAT" /><summary type="html"><![CDATA[준비물]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/18-02-14-IgH-EtherCAT/ethercat.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/18-02-14-IgH-EtherCAT/ethercat.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Windows에서 ARM Linux 크로스 컴파일 환경 구성하기</title><link href="http://localhost:4000/blog/ARM-Linux-Cross-Compile/" rel="alternate" type="text/html" title="Windows에서 ARM Linux 크로스 컴파일 환경 구성하기" /><published>2017-10-27T00:00:00+09:00</published><updated>2017-10-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/ARM-Linux-Cross-Compile</id><content type="html" xml:base="http://localhost:4000/blog/ARM-Linux-Cross-Compile/"><![CDATA[<p>IDE 등으로 배포하기 위해 Windows 플랫폼에서 ARM 크로스 컴파일 환경을 Standalone으로 구성하려고 한다.</p>

<h2 id="준비하기">준비하기</h2>

<p>준비물 : mingw32 arm linux toolchain, cmake, mingw32-make</p>

<p>우선 작업을 위한 폴더를 만든다. 나는 D: 바로 아래에 arm이라는 폴더를 만들었다.
그 폴더 안에 다음 링크를 통해 받은 파일을 저장한다.</p>

<p>mingw32 arm liunux 툴체인 : <a href="https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/">https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/</a><br />
이 사이트에서 “gcc-linaro-[버전]-[날짜]-i686-mingw32_arm-linux-gnueabihf.tar.xz” 파일을 다운받는다.<br />
(다른 버전은 <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">여기</a> 참조)</p>

<p>cmake : <a href="https://cmake.org/files/v3.10/cmake-3.10.0-rc3-win64-x64.zip">https://cmake.org/files/v3.10/cmake-3.10.0-rc3-win64-x64.zip</a><br />
(역시 다른 버전을 원하면 <a href="https://cmake.org/download/">여기</a> 참조)</p>

<p>Standalone으로 구성하기 위해 cmake는 zip 파일로 내려받는다.</p>

<p>위 파일들을 받고 압축을 해제한다.</p>

<p>mingw32-make는 정식 경로에서 Standalone으로 받는 방법은 찾지 못했다. 대신에 다음 사이트에서 mingw-get을 받아 설치한 후 mingw32-make.exe를 가져오는 방법을 사용하였다.<br />
<a href="https://sourceforge.net/projects/mingw/">https://sourceforge.net/projects/mingw/</a></p>

<p>설치 후 mingw-get GUI에서 다음과 같이 mingw32-make를 선택해서 설치하거나</p>

<p><img src="/blog/assets/post/17-10-27-ARM-Linux-Cross-Compile/install_mingw_gui.png" alt="install mingw gui" /></p>

<p>명령 프롬프트에서 설치할 수 있다.</p>

<figure class="highlight"><pre><code class="language-batch" data-lang="batch"><span class="o">&gt;</span> <span class="kd">C</span>:\MinGW\bin\mingw<span class="na">-get</span>.exe <span class="kd">install</span> <span class="kd">mingw32</span><span class="na">-make</span></code></pre></figure>

<p>어떤 방법으로든 설치하고 나면 MinGW 설치 폴더 아래 bin 폴더에 다음과 같은 파일이 생길 것이다.</p>

<p><img src="/blog/assets/post/17-10-27-ARM-Linux-Cross-Compile/mingw_files.png" alt="mingw files" /></p>

<p>이 파일들 중 mingw-get.exe를 제외한 5개 파일을 작업 폴더에 mingw32-make라는 폴더를 만들고 그 아래에 복사한다.</p>

<p>준비물을 모두 챙기고 나면 작업 폴더는 다음과 같이 될 것이다.</p>

<p><img src="/blog/assets/post/17-10-27-ARM-Linux-Cross-Compile/working_directory.png" alt="working directory" /></p>

<h2 id="빌드-형상-정의하기">빌드 형상 정의하기</h2>

<p>이제 툴체인을 명시한 toolchain.arm.cmake 파일을 작성한다.</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nf">SET</span><span class="p">(</span>CMAKE_SYSTEM_NAME Linux<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_SYSTEM_PROCESSOR arm<span class="p">)</span>

<span class="nf">SET</span><span class="p">(</span>COMPILER_ROOT <span class="s2">"D:/arm/gcc-linaro-7.1.1-2017.08-i686-mingw32_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-"</span><span class="p">)</span>

<span class="nf">SET</span><span class="p">(</span>CMAKE_C_COMPILER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>gcc.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_CXX_COMPILER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>g++.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_LINKER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>ld.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_NM <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>nm.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_OBJCOPY <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>objcopy.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_OBJDUMP <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>objdump.exe<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_RANLIB <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>ranlib.exe<span class="p">)</span></code></pre></figure>

<p>경로는 각자 환경에 맞게 수정하면 된다.
파일 구분자를 백슬래시(\)로 입력하면 cmake가 escape character로 처리해서 오류가 생기기 때문에 슬래시(/)로 입력했다.</p>

<h2 id="예제-코드-작성하기">예제 코드 작성하기</h2>

<p>다음과 같이 간단한 예제 소스코드를 작성했다.</p>

<p>main.c</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello arm!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>CMakeLists.txt</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nf">ADD_EXECUTABLE</span><span class="p">(</span>App main.c<span class="p">)</span></code></pre></figure>

<h2 id="빌드하고-실행하기">빌드하고 실행하기</h2>

<p>이제 준비는 모두 끝났으니 빌드하면 된다.</p>

<p>빌드를 편하게 하기 위해 배치 파일을 만들었다.</p>

<p>build.bat</p>

<figure class="highlight"><pre><code class="language-batch" data-lang="batch"><span class="nb">mkdir</span> <span class="kd">build</span>
<span class="nb">cd</span> <span class="kd">build</span>

<span class="s2">"../cmake-3.10.0-rc3-win64-x64/bin/cmake.exe"</span> <span class="na">-DCMAKE</span>_MAKE_PROGRAM<span class="o">=</span><span class="s2">"D:/arm/mingw32-make/mingw32-make.exe"</span> <span class="na">-DCMAKE</span>_TOOLCHAIN_FILE<span class="o">=</span>../toolchain.arm.cmake <span class="na">-G </span><span class="s2">"MinGW Makefiles"</span> ..

<span class="s2">"../cmake-3.10.0-rc3-win64-x64/bin/cmake.exe"</span>  <span class="na">--build </span>.

@echo <span class="na">off</span>
<span class="kd">set</span> <span class="na">/p </span><span class="kd">str</span><span class="o">=</span><span class="kd">completed</span></code></pre></figure>

<p>준비물들이랑 빌드 결과물이 섞이면 곤란하니 build 폴더를 생성하고 그 아래에 빌드 결과물이 생성되도록 하였다.</p>

<p>세 번째 명령어가 매우 긴데, 다음과 같은 일을 한다.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">-DCMAKE_MAKE_PROGRAM</code>: mingw32-make.exe의 경로를 지정한다.(절대경로)<br />
mingw-get을 설치하고 나서는 이 옵션이 없어도 cmake가 알아서 mingw32-make의 경로를 찾아내는데, mingw-get 없이 Standalone으로 실행하려면 이 옵션이 반드시 필요하다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">-DCMAKE_TOOLCHAIN_FILE</code>: 툴체인을 명시한 toolchain.arm.cmake 파일의 경로를 지정한다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">-G "MinGW Makefiles"</code>: mingw32-make.exe가 이해할 수 있는 Makefile을 생성한다.</p>
  </li>
</ul>

<p>build.bat 파일을 실행하고 나면 build 폴더 안에 App이라는 파일이 생성되었을 것이다.</p>

<p>이것을 ARM Linux 플랫폼에 옮기고 실행한다.</p>

<p><img src="/blog/assets/post/17-10-27-ARM-Linux-Cross-Compile/execute.png" alt="execute" /></p>]]></content><author><name>khlee</name></author><category term="Build system" /><summary type="html"><![CDATA[IDE 등으로 배포하기 위해 Windows 플랫폼에서 ARM 크로스 컴파일 환경을 Standalone으로 구성하려고 한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-27-ARM-Linux-Cross-Compile/satellite.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-27-ARM-Linux-Cross-Compile/satellite.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">cmake에서 툴체인 사용하기</title><link href="http://localhost:4000/blog/CMake-Toolchain/" rel="alternate" type="text/html" title="cmake에서 툴체인 사용하기" /><published>2017-10-26T00:00:00+09:00</published><updated>2017-10-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/CMake-Toolchain</id><content type="html" xml:base="http://localhost:4000/blog/CMake-Toolchain/"><![CDATA[<p><a href="https://lklab.github.io/blog/blog/cmake/">지난 번</a>에는 cmake를 사용하여 서로 다른 플랫폼에서 빌드하는 방법을 알아보았는데, 이번엔 한 플랫폼에서 다른 플랫폼 실행 파일을 크로스 컴파일하는 방법을 알아볼 것이다.</p>

<p>예제로, 데스크탑 PC(x86_64 Ubuntu 16.04)에서 ARM Linux 실행 파일을 크로스 컴파일해 볼 것이다.</p>

<p>먼저 툴체인을 받아와서 압축을 해제한다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget https://releases.linaro.org/components/toolchain/binaries/latest/arm-linux-gnueabihf/gcc-linaro-7.1.1-2017.08-x86_64_arm-linux-gnueabihf.tar.xz
<span class="nv">$ </span><span class="nb">tar </span>xf gcc-linaro-7.1.1-2017.08-x86_64_arm-linux-gnueabihf.tar.xz</code></pre></figure>

<p>원하는 버전의 다른 ARM 툴체인은 <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">여기</a>서 찾아볼 수 있다.</p>

<p>이제 toolchain.arm.cmake 라는 파일을 만들어서 내용을 다음과 같이 채워 넣는다.</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nf">SET</span><span class="p">(</span>CMAKE_SYSTEM_NAME Linux<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_SYSTEM_PROCESSOR arm<span class="p">)</span>

<span class="nf">SET</span><span class="p">(</span>COMPILER_ROOT /root/cmake/gcc-linaro-7.1.1-2017.08-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-<span class="p">)</span>

<span class="nf">SET</span><span class="p">(</span>CMAKE_C_COMPILER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>gcc<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_CXX_COMPILER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>g++<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_LINKER <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>ld<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_NM <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>nm<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_OBJCOPY <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>objcopy<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_OBJDUMP <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>objdump<span class="p">)</span>
<span class="nf">SET</span><span class="p">(</span>CMAKE_RANLIB <span class="si">${</span><span class="nv">COMPILER_ROOT</span><span class="si">}</span>ranlib<span class="p">)</span></code></pre></figure>

<p>이 파일은 툴체인의 경로(절대경로)를 명시하는 역할을 한다. 나중에 cmake를 실행할 때 이 파일을 입력해서 빌드시 사용할 툴체인을 지정해줄 수 있다. 첫 번째 줄의 <code class="highlighter-rouge">COMPILER_ROOT</code> 변수는 각자 환경에 맞게 수정하면 된다. 여기서는 앞에서 받아온 ARM 툴체인의 실행파일(gcc, ld 등)들의 경로를 지정하였다.</p>

<p>예제로 빌드할 소스코드(main.c)와 cmake 파일(CMakeLists.txt)를 작성한다.</p>

<p>main.c</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello arm!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>CMakeLists.txt</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nf">ADD_EXECUTABLE</span><span class="p">(</span>App main.c<span class="p">)</span></code></pre></figure>

<p>이제 다음 명령어를 입력하면 빌드된다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cmake <span class="nt">-DCMAKE_TOOLCHAIN_FILE</span><span class="o">=</span>toolchain.arm.cmake <span class="nb">.</span>
<span class="nv">$ </span>make</code></pre></figure>

<p>App 이라는 실행파일이 생성되었을 것이다. file 명령어를 통해 확인해 보면 잘 컴파일 된 것을 확인할 수 있다.</p>

<p><img src="/blog/assets/post/17-10-26-CMake-Toolchain/build.png" alt="build" /></p>

<p>이 파일을 ARM 플랫폼으로 (여기서는 raspberry pi에) 전송한 후에 실행한 화면이다.</p>

<p><img src="/blog/assets/post/17-10-26-CMake-Toolchain/execute.png" alt="execute" /></p>]]></content><author><name>khlee</name></author><category term="Build system" /><summary type="html"><![CDATA[지난 번에는 cmake를 사용하여 서로 다른 플랫폼에서 빌드하는 방법을 알아보았는데, 이번엔 한 플랫폼에서 다른 플랫폼 실행 파일을 크로스 컴파일하는 방법을 알아볼 것이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-26-CMake-Toolchain/chain.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-26-CMake-Toolchain/chain.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity로 VR 캐릭터 컨트롤하는 앱 개발하기</title><link href="http://localhost:4000/blog/Unity-VR-Controller/" rel="alternate" type="text/html" title="Unity로 VR 캐릭터 컨트롤하는 앱 개발하기" /><published>2017-10-25T00:00:00+09:00</published><updated>2017-10-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/Unity-VR-Controller</id><content type="html" xml:base="http://localhost:4000/blog/Unity-VR-Controller/"><![CDATA[<h2 id="소개">소개</h2>

<p>이번엔 <a href="https://lklab.github.io/blog/blog/Unity-VR-Support/">지난 글</a>과 <a href="https://lklab.github.io/blog/blog/Unity-Bluetooth-Controller/">저번 글</a>의 내용을 합쳐서 Bluetooth Controller를 통해 1인칭 캐릭터를 컨트롤할 수 있는 VR앱을 만들 것이다.</p>

<h2 id="준비">준비</h2>

<p>Assets Store에서 <a href="https://www.assetstore.unity3d.com/kr/#!/content/15">괜찮은 프로젝트</a>를 받아온다.<br />
- 2018년 11월 현재 위 프로젝트는 서비스되지 않아서 받아올 수 없다.</p>

<p><img src="/blog/assets/post/17-10-25-Unity-VR-Controller/20171024_224745.png" alt="sample project" /></p>

<h2 id="씬-수정">씬 수정</h2>

<p>필요없는 부분은 다 지우고 먼저 1인칭 캐릭터 역할을 할 GameObject를 적당한 위치에 적당한 크기로 하나 만든다.</p>

<p><img src="/blog/assets/post/17-10-25-Unity-VR-Controller/20171026_001652.png" alt="scene view" /></p>

<p><img src="/blog/assets/post/17-10-25-Unity-VR-Controller/20171026_001706.png" alt="inspector" /></p>

<p>벽과 바닥을 뚫고 다니면 안 되니까 Capsule Collider를 추가하고 물리엔진과 상호작용(중력이라던가 다른 물체와 충돌이라던가)을 할 수 있도록 Rigidbody를 추가한다. 중요한게 Rigidbody에서 Constraints안에 Freeze Rotation의 모든 축을 체크해야 한다. 물리엔진에 의해 캐릭터가 회전하지 않도록 제약을 걸어 두는 것으로, 이렇게 하지 않으면 Capsule Collider의 곡면 때문에 캐릭터가 자기 맘대로 막 굴러다닌다.</p>

<p>그 다음엔 캐릭터 GameObject의 하위 Object로 포함되도록 Camera를 추가한다.</p>

<p><img src="/blog/assets/post/17-10-25-Unity-VR-Controller/20171026_003124.png" alt="scene view" /></p>

<p><img src="/blog/assets/post/17-10-25-Unity-VR-Controller/20171026_003150.png" alt="inspector" /></p>

<p>카메라의 위치는 적당히 잡아주면 된다. 단, X와 Z 좌표는 0으로 해 두는 것이 좋다.</p>

<h2 id="스크립트-작성">스크립트 작성</h2>

<p>이제 스크립트를 하나 추가한다.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="nf">RequireComponent</span> <span class="p">(</span><span class="k">typeof</span> <span class="p">(</span><span class="n">Rigidbody</span><span class="p">))]</span>
<span class="p">[</span><span class="nf">RequireComponent</span> <span class="p">(</span><span class="k">typeof</span> <span class="p">(</span><span class="n">CapsuleCollider</span><span class="p">))]</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">BlueControlManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">GameObject</span> <span class="n">cameraObject</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Rigidbody</span> <span class="n">CharacterRigidbody</span><span class="p">;</span>

    <span class="k">private</span> <span class="kt">bool</span> <span class="n">jumpPushed</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="c1">// contants</span>
    <span class="k">private</span> <span class="kt">float</span> <span class="n">speed</span> <span class="p">=</span> <span class="m">2.2f</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">float</span> <span class="n">gravity</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">bool</span> <span class="n">grounded</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">private</span> <span class="kt">float</span> <span class="n">maxVelocityChange</span> <span class="p">=</span> <span class="m">1.5f</span><span class="p">;</span>

    <span class="k">private</span> <span class="kt">float</span> <span class="n">jumpHeight</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Vector3</span> <span class="n">jumpVelocity</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cameraObject</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"Camera"</span><span class="p">);</span>
        <span class="n">CharacterRigidbody</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Rigidbody</span><span class="p">&gt;();</span>

        <span class="c1">// From the jump height and gravity we deduce the upwards speed </span>
        <span class="c1">// for the character to reach at the apex.</span>
        <span class="n">jumpVelocity</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="m">2</span> <span class="p">*</span> <span class="n">jumpHeight</span> <span class="p">*</span> <span class="n">gravity</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">JoystickButton0</span><span class="p">))</span>
            <span class="n">jumpPushed</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grounded</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// get joystick data</span>
            <span class="n">Vector2</span> <span class="n">joystickPosition</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">();</span>
            <span class="n">joystickPosition</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
            <span class="n">joystickPosition</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>
            <span class="n">joystickPosition</span> <span class="p">=</span> <span class="n">joystickPosition</span><span class="p">.</span><span class="n">normalized</span><span class="p">;</span>

            <span class="c1">// Calculate how fast we should be moving</span>
            <span class="n">Vector3</span> <span class="n">targetVelocity</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
            <span class="n">Vector3</span> <span class="n">forward</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
            <span class="n">Vector3</span> <span class="n">right</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>

            <span class="n">forward</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">cameraObject</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">forward</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
            <span class="n">forward</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">cameraObject</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">forward</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
            <span class="n">right</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">cameraObject</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
            <span class="n">right</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">cameraObject</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
            <span class="n">forward</span> <span class="p">=</span> <span class="n">forward</span><span class="p">.</span><span class="n">normalized</span><span class="p">;</span>
            <span class="n">right</span> <span class="p">=</span> <span class="n">right</span><span class="p">.</span><span class="n">normalized</span><span class="p">;</span>
            <span class="n">targetVelocity</span> <span class="p">=</span> <span class="n">forward</span> <span class="p">*</span> <span class="n">joystickPosition</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">right</span> <span class="p">*</span> <span class="n">joystickPosition</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
            <span class="n">targetVelocity</span> <span class="p">*=</span> <span class="n">speed</span><span class="p">;</span>

            <span class="c1">// Apply a force that attempts to reach our target velocity</span>
            <span class="n">Vector3</span> <span class="n">velocity</span> <span class="p">=</span> <span class="n">CharacterRigidbody</span><span class="p">.</span><span class="n">velocity</span><span class="p">;</span>
            <span class="n">Vector3</span> <span class="n">velocityChange</span> <span class="p">=</span> <span class="p">(</span><span class="n">targetVelocity</span> <span class="p">-</span> <span class="n">velocity</span><span class="p">);</span>
            <span class="n">velocityChange</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">velocityChange</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>
                <span class="p">-</span><span class="n">maxVelocityChange</span><span class="p">,</span> <span class="n">maxVelocityChange</span><span class="p">);</span>
            <span class="n">velocityChange</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">velocityChange</span><span class="p">.</span><span class="n">z</span><span class="p">,</span>
                <span class="p">-</span><span class="n">maxVelocityChange</span><span class="p">,</span> <span class="n">maxVelocityChange</span><span class="p">);</span>
            <span class="n">velocityChange</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="n">CharacterRigidbody</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">velocityChange</span><span class="p">,</span> <span class="n">ForceMode</span><span class="p">.</span><span class="n">VelocityChange</span><span class="p">);</span>

            <span class="c1">// Jump</span>
            <span class="k">if</span><span class="p">(</span><span class="n">jumpPushed</span><span class="p">)</span>
                <span class="n">CharacterRigidbody</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">jumpVelocity</span><span class="p">,</span> <span class="n">ForceMode</span><span class="p">.</span><span class="n">VelocityChange</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">grounded</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">jumpPushed</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">void</span> <span class="nf">OnCollisionStay</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collisionInfo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span><span class="p">(</span><span class="n">ContactPoint</span> <span class="n">contact</span> <span class="k">in</span> <span class="n">collisionInfo</span><span class="p">.</span><span class="n">contacts</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">contact</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;</span> <span class="m">0.7f</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">grounded</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>주요 특징</p>

<ol>
  <li>
    <p>UI 처리는 <code class="highlighter-rouge">Update()</code> 함수에서, 물리적 처리는 <code class="highlighter-rouge">FixedUpdate()</code> 함수에서 한다.<br />
<code class="highlighter-rouge">Update()</code> 함수는 프레임마다 한 번 호출되며, 초당 프레임의 변화에 따라 호출 주기가 달라지는 반면 <code class="highlighter-rouge">FixedUpdate()</code> 함수는 호출 주기가 일정하다. <code class="highlighter-rouge">Input.GetKeyDown()</code> 함수는 버튼이 눌린 시점의 프레임에서만 true를 반환한다. 따라서 <code class="highlighter-rouge">FixedUpdate()</code> 함수에서 <code class="highlighter-rouge">Input.GetKeyDown()</code> 함수로 값을 읽어오는 경우 프레임 타이밍에 따라 버튼을 눌러도 <code class="highlighter-rouge">true</code>값을 읽지 못할 수도 있다. 반면에 물리적 처리는 호출 주기가 일정한 <code class="highlighter-rouge">FixedUpdate()</code> 함수에서 처리해야 자연스럽게 동작하며 그렇지 않고 <code class="highlighter-rouge">Update()</code> 함수에서 처리할 경우 초당 프레임 변화에 따라 다르게 동작할 것이다.</p>
  </li>
  <li>
    <p>캐릭터를 움직일 때는 <code class="highlighter-rouge">rigidbody</code>의 <code class="highlighter-rouge">AddForce()</code> 함수 사용<br />
캐릭터를 움직이는 방법, 즉 캐릭터의 위치를 바꾸는 방법은 위치 자체를 바꾸는 방법, 속도를 바꾸는 방법, 힘(가속도)를 주는 방법의 세 가지가 있다. 위치 자체를 바꾸는 것은 캐릭터가 순간이동하는 것으로 구현될 것이며, 속도를 바꾸거나 힘을 주어야 위치가 연속적으로 변할 것이다. 힘을 주는 방법이 위치와 속도가 연속적으로 변하는 것이므로 가장 자연스럽게 동작할 것이다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">grounded</code> (캐릭터가 땅을 밟고 서 있는지) 판단 조건<br />
캐릭터의 Collider가 다른 Collider와 접촉할 때 호출되는 <code class="highlighter-rouge">OnCollisionStay()</code> 함수에서 항상 <code class="highlighter-rouge">grounded</code>를 <code class="highlighter-rouge">true</code>로 바꾸도록 하면 벽과 접촉할 때에도 땅을 밟고 있다고 판단하여 벽타기가 가능하다. 따라서 <code class="highlighter-rouge">OnCollisionStay()</code> 함수의 인자로 주어지는 Collision 정보 내에서 다른 Collider와 접촉한 방향이 옆쪽이 아닌 아래쪽 방향이 있는 경우에만 땅을 밟고 있다고 판단하게 한다.</p>
  </li>
</ol>

<h2 id="플레이-영상">플레이 영상</h2>

<iframe class="video" src="https://www.youtube.com/embed/6hyWDXpkXFM" allowfullscreen="" frameborder="0"></iframe>]]></content><author><name>khlee</name></author><category term="Unity" /><summary type="html"><![CDATA[소개]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-25-Unity-VR-Controller/unity_vr_controller.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-25-Unity-VR-Controller/unity_vr_controller.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity VR Support</title><link href="http://localhost:4000/blog/Unity-VR-Support/" rel="alternate" type="text/html" title="Unity VR Support" /><published>2017-10-24T00:00:00+09:00</published><updated>2017-10-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/Unity-VR-Support</id><content type="html" xml:base="http://localhost:4000/blog/Unity-VR-Support/"><![CDATA[<p>화면 출력 관점에서 모바일에서 동작하는 VR 앱을 개발하기 위해서는 화면을 반으로 나누고, 각 화면의 시점(카메라)을 다르게 해서 3D로 보이도록 만들며, 기기의 센서 정보를 이용해 그에 맞게 시점을 회전하는 head tracking 등등이 필요하다.</p>

<p>예전에 처음 Unity를 사용해 VR 앱을 개발할 때에는 센서 값을 읽어오는 플러그인을 넣고, 카메라를 두 개 만든 다음 센서 값에 따라 카메라를 회전하는걸 직접 구현했었는데, 지금은 Unity에서 자동으로 해 준다. 카드보드, 데이드림, 오큘러스 등등의 VR 플랫폼 지원까지 해준다. 관련 내용은 <a href="https://docs.unity3d.com/Manual/VROverview.html">문서</a>에 잘 나와 있다.</p>

<p>이번 글은 Unity에서 다 해주므로. 분량이 없다. Edit -&gt; Project Settings -&gt; Player에 들어가서 원하는 플랫폼에 대해 Virtual Reality Supported에 체크한방 날리고 카드보드인지 아니면 다른 플랫폼인지 선택하면 끝이다.</p>

<p><img src="/blog/assets/post/17-10-24-Unity-VR-Support/20171023_234700.png" alt="player settings" /></p>

<p><img src="/blog/assets/post/17-10-24-Unity-VR-Support/20171023_234901.png" alt="player settings" /></p>

<p>알아서 화면도 나눠주고 렌즈를 통해 보기 편하도록 화면 왜곡도 해 주며 head tracking도 된다.</p>

<p><img src="/blog/assets/post/17-10-24-Unity-VR-Support/Screenshot_20171023-235321.png" alt="demo" /></p>

<p>카드보드를 선택하면 안드로이드 4.4 Kit Kat (API level 19) 부터, 데이드림을 선택하면 안드로이드 7.0 Nougat (API level 24) 부터 앱을 실행할 수 있다.</p>]]></content><author><name>khlee</name></author><category term="Unity" /><summary type="html"><![CDATA[화면 출력 관점에서 모바일에서 동작하는 VR 앱을 개발하기 위해서는 화면을 반으로 나누고, 각 화면의 시점(카메라)을 다르게 해서 3D로 보이도록 만들며, 기기의 센서 정보를 이용해 그에 맞게 시점을 회전하는 head tracking 등등이 필요하다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-24-Unity-VR-Support/Screenshot_20171023-235321.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-24-Unity-VR-Support/Screenshot_20171023-235321.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity에서 Bluetooth Controller 제어</title><link href="http://localhost:4000/blog/Unity-Bluetooth-Controller/" rel="alternate" type="text/html" title="Unity에서 Bluetooth Controller 제어" /><published>2017-10-18T00:00:00+09:00</published><updated>2017-10-18T00:00:00+09:00</updated><id>http://localhost:4000/blog/Unity-Bluetooth-Controller</id><content type="html" xml:base="http://localhost:4000/blog/Unity-Bluetooth-Controller/"><![CDATA[<h2 id="컨트롤러-소개">컨트롤러 소개</h2>

<p>VR 앱을 개발하기 위해 아이페가 PG-9068 TOMAHAWK 모델의 블루투스 컨트롤러를 구입하였다.</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/controller_01.jpeg" alt="controller" class="custom-align-center-img" /></p>

<p>집에 도착한 모습</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/controller_02.jpeg" alt="controller" class="custom-align-center-img" />
<img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/controller_03.jpeg" alt="controller" class="custom-align-center-img" /></p>

<p>Xbox 컨트롤러와 유사한 구조를 갖고 있다.</p>

<h2 id="unity에서-컨트롤러-입력값을-읽어오기">Unity에서 컨트롤러 입력값을 읽어오기</h2>

<p>Unity에서 컨트롤러의 입력값을 읽어오기 위해서는 각 버튼이 어떻게 매핑되어 있는지 알아야 한다. 직접 테스트해본 결과 다음 그림과 같이 매핑되어 있었다.</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/mapping.png" alt="mapping" /></p>

<p>OS와 컨트롤러에 따라 매핑 정보는 달라질 수 있다. 따라서 출시되는 VR 앱에는 이를 잘 파악하여 동적으로 매핑 정보를 파악할 수 있도록 해야 한다.</p>

<p>그림에서 “JoystickButton*” 로 매핑되는 버튼은 Digital 값이고, “*th axis”로 매핑되는 조이스틱이나 버튼은 Analog 값이다. Digital인가 Analog인가에 따라 Unity에서 값을 읽어오는 방식이 다르다.
(LT, RT 버튼은 Digital과 Analog 방식 모두 동작한다.)</p>

<h2 id="digital-입력">Digital 입력</h2>

<p>먼저 Digital 값은 스크립트에서 다음과 같이 쉽게 읽어올 수 있다.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">bool</span> <span class="n">key_value</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetKey</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">JoystickButton0</span><span class="p">);</span></code></pre></figure>

<p><a href="https://docs.unity3d.com/kr/current/ScriptReference/KeyCode.html">Unity reference</a>를 확인해 보면 <code class="highlighter-rouge">KeyCode</code>의 다양한 값을 볼 수 있다. 최대 8개까지의 조이스틱(컨트롤러)를 구분할 수 있으며 각 컨트롤러마다 최대 20개의 버튼을 구분할 수 있다. 이 값을 <code class="highlighter-rouge">Input.GetKey()</code> 함수의 인자로 주면 버튼 값을 <code class="highlighter-rouge">True</code>나 <code class="highlighter-rouge">False</code>로 돌려 준다. 물론 <code class="highlighter-rouge">Input.GetKeyDown()</code> 이나 <code class="highlighter-rouge">Input.GetKeyUp()</code> 등의 다른 함수도 사용할 수 있다.</p>

<h2 id="analog-입력">Analog 입력</h2>

<p>Analog 값은 조금 복잡한데, 우선 스크립트에서 읽는 방법은 다음과 같다. -1.0 ~ 1.0 범위의 값을 얻을 수 있다.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">float</span> <span class="n">key_value</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span></code></pre></figure>

<p><code class="highlighter-rouge">Input.GetAxis()</code> 함수를 사용하는데, 인자로 주는 string은 읽으려는 axis의 이름이다. Unity는 기본적으로 컨트롤러의 첫 번째 조이스틱에 <code class="highlighter-rouge">"Horizontal"</code>, <code class="highlighter-rouge">"Vertical"</code> axis가 매핑되어 있다. 이러한 정보는 Edit -&gt; Project Settings -&gt; Input에서 설정 가능하다.</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/input_settings.png" alt="input settings" /></p>

<p>설정 창을 열게 되면 Inspector에 다음과 같이 InputManager가 보일 것이다.</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/input_manager.png" alt="input manager" /></p>

<p>다양한 Axis 이름들이 정의되어 있는데, 그 중에서 <code class="highlighter-rouge">"Horizontal"</code>, <code class="highlighter-rouge">"Vertical"</code> axis가 미리 정의되어 있는 것을 볼 수 있다. 또 다른 Analog 입력을 추가하고 싶다면 InputManager의 가장 위에 있는 속성인 <code class="highlighter-rouge">Size</code> 값을 늘린 후에 추가된 항목에 값을 채워넣으면 된다.</p>

<p>여기서는 다음과 같이 오른쪽 조이스틱을 입력으로 추가했다.</p>

<p><img src="/blog/assets/post/17-10-18-Unity-Bluetooth-Controller/joystick_settings.png" alt="joystick settings" /></p>

<p>각 속성에 대한 상세한 내용은 <a href="https://docs.unity3d.com/kr/2018.4/Manual/ConventionalGameInput.html">여기</a> 참조</p>

<p>가장 위에 있는 Name 속성에 입력하는 string을 스크립트에서 <code class="highlighter-rouge">Input.GetAxis()</code> 등의 함수에 인자로 사용하여 해당 Analog 입력 값을 받아올 수 있다. Axis 속성에는 앞서 언급했던, 버튼과 조이스틱이 매핑된 axis를 선택하면 된다. 오른쪽 조이스틱은 X 축이 3rd axis에, Y 축이 4th axis에 매핑되어 있다고 했으므로 그에 맞게 설정하였다.</p>]]></content><author><name>khlee</name></author><category term="Unity" /><summary type="html"><![CDATA[컨트롤러 소개]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-18-Unity-Bluetooth-Controller/controller_02.jpeg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-18-Unity-Bluetooth-Controller/controller_02.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">mldivide (‘\‘)를 활용한 linear regression</title><link href="http://localhost:4000/blog/mldivide/" rel="alternate" type="text/html" title="mldivide (‘\‘)를 활용한 linear regression" /><published>2017-10-17T00:00:00+09:00</published><updated>2017-10-17T00:00:00+09:00</updated><id>http://localhost:4000/blog/mldivide</id><content type="html" xml:base="http://localhost:4000/blog/mldivide/"><![CDATA[<h2 id="정의">정의</h2>

<p>행렬 왼쪽 나눗셈(mldivide, \)은 행렬 <script type="math/tex">A</script>, <script type="math/tex">X</script>, <script type="math/tex">Y</script>로 이루어진 다음 시스템에 대해</p>

<script type="math/tex; mode=display">A \times X = Y</script>

<p>다음과 같이 정의된다.</p>

<script type="math/tex; mode=display">A \setminus Y = X</script>

<script type="math/tex; mode=display">A \times (A \setminus Y) = Y</script>

<p><script type="math/tex">A</script>가 역행렬이 존재하는 정사각 행렬일 경우 다음과 같이 계산할 수 있다.</p>

<script type="math/tex; mode=display">A \setminus Y = A^{-1} \times Y = X</script>

<p>그러나 mldivide는 <script type="math/tex">A</script>의 역행렬이 존재하지 않거나 심지어 정사각 행렬이 아닐 경우에도 정의되는데, 이를 계산하기 위해 다음 링크에 있는 MATLAB 문서는 다음과 같이 그 알고리즘을 설명하고 있다.</p>

<p><a href="https://kr.mathworks.com/help/matlab/ref/mldivide.html#bt4jslc-6">https://kr.mathworks.com/help/matlab/ref/mldivide.html#bt4jslc-6</a></p>

<p>복잡한 알고리즘은 모두 A가 정사각 행렬인 경우에 대한 내용이고, 정사각 행렬이 아닌 경우 QR solver로 해결하도록 되어 있다. MATLAB에는 mldivide 연산에 위와 같은 알고리즘이 구현되어 있어서, 이를 통해 정사각 행렬이 아닌 경우에도 연산이 가능하며, 나아가 linear regression도 mldivide로 계산할 수 있다.</p>

<h2 id="의미">의미</h2>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix}
    a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\
    a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\
    \vdots & \vdots & \ddots & \vdots\\
    a_{n,1} & a_{n,2} & \cdots & a_{n,m}
\end{bmatrix}
\setminus
\begin{bmatrix}
    y_{1,1} & y_{1,2} & \cdots & y_{1,l}\\
    y_{2,1} & y_{2,2} & \cdots & y_{2,l}\\
    \vdots & \vdots & \ddots & \vdots\\
    y_{n,1} & y_{n,2} & \cdots & y_{n,l}
\end{bmatrix}
=
\begin{bmatrix}
    x_{1,1} & x_{1,2} & \cdots & x_{1,l}\\
    x_{2,1} & x_{2,2} & \cdots & x_{2,l}\\
    \vdots & \vdots & \ddots & \vdots\\
    x_{m,1} & x_{m,2} & \cdots & x_{m,l}
\end{bmatrix} %]]></script>

<p>위 그림과 같이 행렬 <script type="math/tex">A</script>의 크기를 <script type="math/tex">n \times m</script>, <script type="math/tex">Y</script>의 크기를 <script type="math/tex">n \times l</script>로 정의할 경우 <script type="math/tex">n</script>, <script type="math/tex">m</script>, <script type="math/tex">l</script>은 각각 다음을 의미한다.</p>

<ul>
  <li><script type="math/tex">n</script> : 시스템을 이루는 식의 수</li>
  <li><script type="math/tex">m</script> : 시스템을 이루는 미지수의 수 (차원)</li>
  <li><script type="math/tex">l</script> : 시스템의 개수 (각 시스템은 동일한 계수를 갖지만, 미지수와 상수는 다름)</li>
</ul>

<p>예를 들어 다음과 같은 시스템에 대해</p>

<script type="math/tex; mode=display">\begin{cases}
2x+3y-z=5\\
x-y+z=2\\
3x+2y-3z=-2
\end{cases}</script>

<p>행렬로 다음과 같이 표현할 수 있고, mldivide로 해를 구할 수 있다.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix}
    2 & 3 & -1\\
    1 & -1 & 1\\
    3 & 2 & -3
\end{bmatrix}
\setminus
\begin{bmatrix}
    5\\
    2\\
    -2
\end{bmatrix}
=
\begin{bmatrix}
    1\\
    2\\ 
    3
\end{bmatrix} %]]></script>

<p><script type="math/tex">n</script>과 <script type="math/tex">m</script>이 동일하면서 <script type="math/tex">A</script>의 rank가 <script type="math/tex">m</script>과 같은 경우, 즉 역행렬이 존재하는 경우는 위와 같이 풀이가 가능하다.</p>

<p>그러나 정사각 행렬이 아닌 경우 <script type="math/tex">n</script>과 <script type="math/tex">m</script>의 관계에 따라 mldivide는 다음과 같은 의미를 갖는다.</p>

<ul>
  <li><script type="math/tex">n</script>(또는 <script type="math/tex">A</script>의 rank)이 <script type="math/tex">m</script>보다 작은 경우 : 무수히 많은 해</li>
  <li><script type="math/tex">n</script>이 <script type="math/tex">m</script>보다 큰 경우 : Least square를 만족하는 Linear regression</li>
</ul>

<p><script type="math/tex">n</script>이 <script type="math/tex">m</script>보다 작은 경우 mldivide는 다음과 같이 <script type="math/tex">m - n</script>개에 해당하는 미지수를 <script type="math/tex">0</script>으로 설정한 후 나머지 미지수에 대한 값을 계산한다.</p>

<p><img src="/blog/assets/post/17-10-17-mldivide/20171018_111803.png" alt="mldivide result" /></p>

<h2 id="linear-regression">Linear Regression</h2>

<p><script type="math/tex">n</script>이 <script type="math/tex">m</script>보다 큰 경우 선형 시스템 상에서는 해가 존재하지 않게 된다. 대신에 mldivide는 Least square를 만족하는 Linear regression으로 동작한다. 따라서 다음 식과 같이 행렬곱이 mldivide의 역연산이 될 수 없다.</p>

<script type="math/tex; mode=display">A \times (A \setminus Y) \neq Y</script>

<p>Linear regression의 경우 <script type="math/tex">n</script>, <script type="math/tex">m</script>의 의미는 다음과 같이 재 정의될 수 있다. <script type="math/tex">l</script>은 동일한 데이터, 속성에 대한 단순 반복이므로 중요하지 않다.</p>

<ul>
  <li><script type="math/tex">n</script> : 데이터의 수</li>
  <li><script type="math/tex">m</script> : 속성의 수</li>
</ul>

<p>이에 따라 행렬 <script type="math/tex">A</script>는 기존의 계수 행렬(Coefficient Matrix)에서 각 속성들의 관계를 나타내는 데이터들의 집합, 즉 Training data의 집합으로 재해석할 수 있고, <script type="math/tex">Y</script> 행렬도 동일하게 Training data 집합의 속성을 갖는다. Linear regression의 결과인 <script type="math/tex">X</script> 행렬은 각 속성들의 가중치를 나타낸다.</p>

<p>가장 간단하게, <script type="math/tex">n</script>개의 두 속성 <script type="math/tex">x</script>, <script type="math/tex">y</script>를 갖는 데이터를 이용하여 다음과 같은 선형 모델로 Regression할 때</p>

<script type="math/tex; mode=display">b+ax=y</script>

<p>행렬 <script type="math/tex">A</script>, <script type="math/tex">Y</script>와 <script type="math/tex">X</script>는 다음과 같이 정의된다.</p>

<script type="math/tex; mode=display">% <![CDATA[
A=
\begin{bmatrix}
    1 & x_{1}\\
    1 & x_{2}\\
    \vdots & \vdots\\
    1 & x_{n}
\end{bmatrix}
Y=
\begin{bmatrix}
    y_{1}\\
    y_{2}\\
    \vdots\\
    y_{n}
\end{bmatrix}
X=
\begin{bmatrix}
    b\\
    a
\end{bmatrix} %]]></script>

<p>행렬 <script type="math/tex">A</script>는 상수항을 의미하는 <script type="math/tex">1</script>로 이루어진 열과 각각의 속성에 해당하는 데이터로 이루어진 열들로 구성되며, <script type="math/tex">Y</script>는 남은 한 속성에 해당하는 데이터로 구성된다. 행렬 <script type="math/tex">X</script>는 상수항과 속성의 계수로 구성되며, 선형 모델을 나타낸다.</p>

<p>예를 들어서 키와 몸무게 사이의 관계에 관한 Linear regression 문제를 MATLAB을 사용하여 푸는 방법은 다음과 같다.</p>

<p><img src="/blog/assets/post/17-10-17-mldivide/linear_regression.png" alt="linear regression" class="custom-align-center-img" />
<em class="custom-caption">데이터 : <a href="https://github.com/johnmyleswhite/ML_for_Hackers/blob/master/07-Optimization/data/01_heights_weights_genders.csv">https://github.com/johnmyleswhite/ML_for_Hackers/blob/master/07-Optimization/data/01_heights_weights_genders.csv</a></em></p>

<p>최종적으로 다음과 같은 선형 모델을 얻게 된다.</p>

<script type="math/tex; mode=display">-350.7372+7.7173x_{height}=y_{weight}</script>

<h2 id="계산">계산</h2>

<p><script type="math/tex">n > m</script>인 행렬 <script type="math/tex">A</script>에 대해 일반적인 경우에는 다음과 같이 계산이 가능하다.</p>

<script type="math/tex; mode=display">X = A \setminus Y = (A^{T} \times A)^{-1} \times A^{T} \times Y</script>

<p>MATLAB에서는 다음과 같이 입력하면 된다.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="nb">inv</span><span class="p">(</span><span class="nb">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="nb">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span></code></pre></figure>

<p>그러나 다음 행렬과 같이 데이터의 스케일 차이가 큰 경우 부동소수점 연산 정밀도의 한계로, 정확한 해를 구할 수 없게 된다.</p>

<p><img src="/blog/assets/post/17-10-17-mldivide/20171018_114105.png" alt="calculation" /></p>

<p>MATLAB에는 해를 구하기 위해 다음의 여러 가지 방법들을 제공한다.</p>

<ul>
  <li>QR Solver :<br />
  [Q, R] = qr(A, 0)<br />
  X = R \ (Q’ * Y)</li>
  <li>X = pinv(A) * Y</li>
  <li>X = linsolve(A, Y)</li>
  <li>inv(transpose(A) * A) * transpose(A) * Y</li>
</ul>

<p>앞의 예제를 각각의 방법으로 구한 해와 RMSE는 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">exact solution</th>
      <th style="text-align: center">A \ Y</th>
      <th style="text-align: center">QR Solver</th>
      <th style="text-align: center">pinv</th>
      <th style="text-align: center">linsolve</th>
      <th style="text-align: center">transpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">b</td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">-0.0127</td>
      <td style="text-align: center">-0.0555</td>
      <td style="text-align: center">-0.0313</td>
      <td style="text-align: center">-0.0127</td>
      <td style="text-align: center">0.0041</td>
    </tr>
    <tr>
      <td style="text-align: center">a</td>
      <td style="text-align: center">1.0</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
    </tr>
    <tr>
      <td style="text-align: center">RMSE</td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">0.0078</td>
      <td style="text-align: center">0.0349</td>
      <td style="text-align: center">0.0590</td>
      <td style="text-align: center">0.0078</td>
      <td style="text-align: center">0.1243</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">A \ Y</code>와 <code class="highlighter-rouge">linsolve</code>의 성능이 가장 좋은 것을 확인할 수 있다.</p>

<p>반면 상수항에 비해 데이터가 작은 경우에는 <code class="highlighter-rouge">QR Solver</code>가 가장 정확했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">exact solution</th>
      <th style="text-align: center">A \ Y</th>
      <th style="text-align: center">QR Solver</th>
      <th style="text-align: center">pinv</th>
      <th style="text-align: center">linsolve</th>
      <th style="text-align: center">transpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">b</td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">-1.05998e-28</td>
      <td style="text-align: center">-5.5511e-29</td>
      <td style="text-align: center">-8.2740e-29</td>
      <td style="text-align: center">-1.05998e-28</td>
      <td style="text-align: center">-1.4724e-28</td>
    </tr>
    <tr>
      <td style="text-align: center">a</td>
      <td style="text-align: center">1.0</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
      <td style="text-align: center">1.0000</td>
    </tr>
    <tr>
      <td style="text-align: center">RMSE</td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">5.6798e-29</td>
      <td style="text-align: center">3.1554e-29</td>
      <td style="text-align: center">4.0409e-29</td>
      <td style="text-align: center">5.6798e-29</td>
      <td style="text-align: center">6.1834e-29</td>
    </tr>
  </tbody>
</table>

<p>경우에 따라 다른 방법의 성능이 더 좋을 수 있으며, 데이터의 특성에 따라 적절한 방법을 선택해야 한다.</p>]]></content><author><name>khlee</name></author><category term="Machine Learning" /><summary type="html"><![CDATA[행렬 왼쪽 나눗셈이 linear regression으로 동작하는 원리에 대해 서술한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-10-17-mldivide/mldivide.jpeg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-10-17-mldivide/mldivide.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">cmake를 활용하여 windows와 linux 모두에서 빌드 가능한 프로젝트 만들기</title><link href="http://localhost:4000/blog/cmake/" rel="alternate" type="text/html" title="cmake를 활용하여 windows와 linux 모두에서 빌드 가능한 프로젝트 만들기" /><published>2017-07-31T00:00:00+09:00</published><updated>2017-07-31T00:00:00+09:00</updated><id>http://localhost:4000/blog/cmake</id><content type="html" xml:base="http://localhost:4000/blog/cmake/"><![CDATA[<h2 id="개요">개요</h2>

<p>이번 글에서는 제목과 같이 cmake 툴을 활용해서 Windows와 Linux 모두에서 빌드할 수 있는 프로젝트를 만들어 볼 것이다. 우선 cmake는 소스코드들과 그 결과물인 바이너리, 라이브러리의 구조를 추상화해서 빌드 플랫폼에 의존적인 Makefile(이나 등등)을 생성해내는 도구이다. 자세한건 <a href="https://www.tuwlab.com/ece/27234">여기</a>를 참고하자.</p>

<h2 id="설치">설치</h2>

<p>먼저 cmake를 설치한다. <a href="https://cmake.org/download/">https://cmake.org/download/</a> 이 사이트에서 플랫폼에 맞는 바이너리를 받을 수도 있고 아니면 <a href="https://lklab.github.io/blog/blog/Raspberry-Pi-EtherCAT/">https://lklab.github.io/blog/blog/Raspberry-Pi-EtherCAT/</a> 처럼 소스코드를 받아서 직접 빌드할 수도 있다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>apt-get <span class="nb">install </span>cmake</code></pre></figure>

<p>이렇게 해도 된다.</p>

<h2 id="플랫폼별-분기">플랫폼별 분기</h2>

<p><a href="https://github.com/lklab/cmake_test">예제</a>를 기준으로 Windows와 Linux 각각 플랫폼에 대해 다른 빌드 구조나 소스코드를 선택하는 법과, 실제 빌드를 어떻게 수행하는지 알아볼 것이다.</p>

<p>먼저 cmake의 빌드 구조를 정의한 CMakeLists.txt 파일에서는 현재 빌드 플랫폼이 무엇인지 다음과 같이 확인할 수 있다.</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">if</span><span class="p">(</span>WIN32<span class="p">)</span>
    <span class="nb">message</span><span class="p">(</span><span class="s2">"win 32 build!"</span><span class="p">)</span>
<span class="nb">elseif</span><span class="p">(</span>UNIX<span class="p">)</span>
    <span class="nb">message</span><span class="p">(</span><span class="s2">"linux build!"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span></code></pre></figure>

<p><code class="highlighter-rouge">if</code>문과 <code class="highlighter-rouge">WIN32</code>, <code class="highlighter-rouge">UNIX</code> 키워드를 통해서 확인이 가능하다. Windows 64 타겟으로 빌드할 때에도 <code class="highlighter-rouge">WIN32</code> 키워드가 활성화된다. 이 분기문을 통해 각 빌드 플랫폼에 따라 서로 다른 소스코드나 라이브러리를 선택하는 등의 빌드 구조를 정의할 수 있다.</p>

<p>타겟 플랫폼에 따라 소스코드 파일을 따로 작성할 수도 있지만 그 양이 많지 않다면 한 소스파일 내에서 전처리기 매크로로 구분하는 방법도 좋다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#if defined(_WIN64)
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"_WIN64!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#elif defined(_WIN32)
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"_WIN32!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#elif defined(__linux__)
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"__linux__"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"64!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"32!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif</span></code></pre></figure>

<h2 id="빌드">빌드</h2>

<p>마지막으로 각 플랫폼에서의 빌드 방법이다. 먼저 Linux에서는</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">mkdir </span>build
<span class="nv">$ </span><span class="nb">cd </span>build
<span class="nv">$ </span>cmake ..
<span class="nv">$ </span>make</code></pre></figure>

<p>이렇게 하면 된다.</p>

<p>Windows에서는 조금 더 복잡하다. 우선 Visual Studio를 설치해야 한다. cmd.exe나 Visual Studio 명령 프롬프트를 열어서 다음과 같이 명령어를 입력한다.</p>

<figure class="highlight"><pre><code class="language-batch" data-lang="batch"><span class="o">&gt;</span> <span class="nb">mkdir</span> <span class="kd">build</span>
<span class="o">&gt;</span> <span class="nb">cd</span> <span class="kd">build</span>
<span class="o">&gt;</span> <span class="s2">"C:\Program Files\CMake\bin\cmake.exe"</span> .. <span class="na">-G </span><span class="s2">"Visual Studio 15 2017 Win64"</span>
<span class="o">&gt;</span> <span class="s2">"C:\Program Files\CMake\bin\cmake.exe"</span> <span class="na">--build </span>. <span class="na">--config </span><span class="kd">Release</span></code></pre></figure>

<p>cmake.exe의 경로는 자신의 환경에 맞게 바꾸면 되고, 자신이 설치한 Visual Studio 버전에 따라 3번째 명령어를 다르게 하면 된다. <code class="highlighter-rouge">cmake.exe -G</code> 명령어를 실행하면 큰 따옴표 사이에 넣을 수 있는 내용이 쭉 나온다. 여기서 알맞은 것을 선택하면 된다.</p>

<p><img src="/blog/assets/post/17-07-31-cmake/20170731_182546.png" alt="cmake targets" /></p>

<p>엄청 많이 나온다. Makefile뿐만 아니라 각 IDE의 프로젝트를 그냥 생성해준다.</p>

<p>Visual Studio에 있는 [arch] 부분에는 32비트 타겟으로 빌드할 경우 생략, 64비트 타겟으로 빌드할 경우 <code class="highlighter-rouge">WIN64</code>라고 입력해주면 된다.</p>]]></content><author><name>khlee</name></author><category term="Build system" /><summary type="html"><![CDATA[개요]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-31-cmake/cmake_logo.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-31-cmake/cmake_logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">UPPAAL2PLC 개선작업</title><link href="http://localhost:4000/blog/Improving-UPPAAL2PLC/" rel="alternate" type="text/html" title="UPPAAL2PLC 개선작업" /><published>2017-07-26T00:00:00+09:00</published><updated>2017-07-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/Improving-UPPAAL2PLC</id><content type="html" xml:base="http://localhost:4000/blog/Improving-UPPAAL2PLC/"><![CDATA[<p><a href="https://lklab.github.io/blog/blog/UPPAAL2PLC/">지난 글</a>에서 소개한 UPPAAL2PLC는 아직 개선해야 할 점이 남아있다. 현재 UPPAAL2PLC는 UPPAAL에서 모델링 가능한 모든 모델을 지원하지 못하고 제한적으로 지원한다. 예를 들어 태스크는 하나만 있어야 하고, 비결정적 전이를 올바르게 구현하지 않는다는 제한사항이 있다.
이번 글에서는 UPPAAL2PLC의 추후 개선 방향과, 정형 모델과 실제 시스템의 차이로 인한 상호 변환의 어려움에 대해 기술할 것이다.</p>

<h2 id="시간의-연속성과-동시성-가설">시간의 연속성과 동시성 가설</h2>

<p>UPPAAL에서 사용하는 정형 언어인 타임드 오토마타의 의미론(Semantics)에서는 시간 값, 즉 clock 변수의 값은 연속적이다. 그러나 컴퓨터 시스템에서는 시간성을 구현하기 위해서 일정 주기 단위로 반복 수행하는 방법을 사용하는데, 이 경우 각 주기마다 시간은 동일한 것으로 표현되어 이산적인 시간 값을 갖게 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/continuous_time_discrete_time.png" alt="continuous time and discrete time" class="custom-align-center-img" />
<em class="custom-caption">&lt;연속적인 실제 시간과 이산적인 시간&gt;<br />
실제 시간은 각 시점마다 연속적인 실수 값으로 표현되지만 이산적인 시간은 한 주기 내에서 동일한 값으로 표현된다.</em></p>

<p>이를 해결하기 위해 주기를 짧게 해서 이산적인 시간 값으로 최대한 연속적인 시간을 흉내 내게 하는 방법이 있을 것이다. 하지만 이것은 엄격한 의미가 중요시되는 정형 기법에서는 허용되지 않는다. 이러한 차이로 인해 모델과 실제 동작 사이에 차이가 생길 수 있기 때문이다.
그렇다면 타임드 오토마타의 의미론을 약간 수정하면 어떨까? 연속적인 시간 값을 사용하지 않는 것이다. 사실 이것을 위한 준비가 이미 되어 있다. 지난 글에서 UPPAAL에서 모델을 개발할 때 반드시 포함해야 하는 템플릿, 시스템 템플릿이 있다고 했다. 이 템플릿에서 연속적인 clock 값을 이용하여 주기적으로 <code class="highlighter-rouge">dataExchanged</code> 채널을 출력한다. 이 채널의 출력 주기가 바로 이산적인 시간을 의미하게 된다. 프로그램 템플릿에서는 이 채널을 수신하여 이산적인 시간을 모델링할 수 있다. 또한, 주기 clock 값의 배수만 사용하는 것으로 제한해도 이산적인 시간을 표현하는 것이 된다. 단, 환경 템플릿에서는 이 제한을 지키지 않아도 된다. 더 좋은 검증을 위해서는 환경 템플릿에 한해 이러한 제한을 지키지 않는 것이 좋다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/system_template.png" alt="system template" class="custom-align-center-img" />
<em class="custom-caption">&lt;시스템 템플릿&gt;<br />
주기적으로 dataExchanged 채널을 출력한다. 이 채널을 받을 때마다 시간 값이 주기만큼 증가한다고 모델링한다.</em></p>

<p>동시성 가설은 어떤 실행이 한 순간에 완료된다고 가정하는 것이다. 타임드 오토마타의 의미론에서는 동시성 가설이 적용되어, 전이라던가 guard 검사, update 수행 등이 모두 시간의 흐름 없이 진행된다. 또한 urgent, committed location 등과 같이 아예 의미적으로 시간이 흐르지 않고 바로 다음 상태로 전이되어야 하는 상태도 존재한다. 이것은 앞에서 언급한 모델에 이산적인 시간을 도입하는 것으로 어느 정도 해결된다. 한 주기 내에서는 시간이 동일한 것으로 표현되므로, 그 주기 내에 실행되는 것들은 모두 실행 시간이 없는 것이 된다. 다만 로드가 심해서 한 주기 동안 수행되어야 할 모든 일을 주기 내에 마치지 못하면 왜곡이 발생한다. 이전 주기에 시작되어 다음 주기에 끝난 태스크는 그 수행 시간이 이미 한 주기 만큼의 시간이 되기 때문이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" alt="concurrency hypothesis" class="custom-align-center-img" />
<em class="custom-caption">&lt;동시성 가설의 구현&gt;<br />
이산적인 시간 표현에서는 한 주기 내에 태스크가 실행되고 종료되면 그 수행 시간이 0인 것으로 표현된다. 그러나 주기를 넘어가게 되면 수행 시간이 한 주기 만큼의 시간이 된다.</em></p>

<p>보다 근본적으로 모델의 시간을 구현하기 위해선 엄밀한 주기성이 필수적이다. 즉 주기가 실제 시간으로 얼마나 시간을 정확히 맞추느냐는 것이다. 따라서 실시간 성능이 좋은 플랫폼 상에서만 모델의 시간이 실제 시간으로 잘 구현될 수 있다.
모델의 시간은 주기의 횟수로 구현된다고 생각하면 의미적으로 정확하다. 예를 들어 모델 시간으로 3을 주기라고 생각한다면, “clock 값이 0에서 12까지 증가하는 동안”이라는 의미는 구현 관점에서 “4번의 주기가 수행되는 동안”과 동일한 의미가 된다.
정리해서, UPPAAL에서 <code class="highlighter-rouge">dataExchanged</code> 채널과 주기 클럭의 배수만 사용하도록 제한하고, 한 주기 내에 필요한 모든 작업이 반드시 완료되면 시간의 연속성과 동시성 가설 문제는 해결될 수 있다.</p>

<h2 id="비결정적-전이">비결정적 전이</h2>

<p>타임드 오토마타의 의미론에서는, 현재 상태에서 채널이나 guard 조건 등을 만족한 전이가 여러 개 있을 경우 그것들 중 하나를 랜덤으로 선택하여 전이를 수행하거나, invariant 등의 조건이 만족한다면 아예 전이가 일어나지 않을 수 있다. 즉, 수행 트레이스를 정확히 예측할 수 없는 비결정성이 존재한다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/non-deterministic_transition_01.png" alt="non-deterministic transition" class="custom-align-center-img" />
<em class="custom-caption">&lt;비결정적인 전이가 일어날 수 있는 예&gt;<br />
value의 값이 150이라면, 초기 Initial 상태에서 다음 상태에 L0이나 L1 또는 L2 상태가 될 수 있고 그대로 Initial 상태에 머무를 수도 있다.</em></p>

<p>이러한 특징을 구현하기 위해서는 현재 상태에서 모든 가능한 다음 상태를 리스트로 구한 다음 그들 중 하나를 랜덤함수를 이용하여 선택하는 방법이 사용될 수 있다. 그러나 비결정성이 반드시 필요한가? 게임 등에서는 여러분의 장비를 강화할 때 일정 확률로 부서지게 하는 기능에는 사용될 수 있겠지만 산업 장치들을 제어하는 프로그램에서 어떻게 실행될지 예측하지 못하는 기능이 효용성이 있을지는 생각해 봐야 한다. 물론, 타임드 오토마타의 시멘틱스를 온전하게 구현하면 정형 검증에 대한 보장을 가져갈 수 있지만, 쓸모 없는 기능을 위해 계산 시간을 낭비하는 것도 피해야 할 요소이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/non-deterministic_transition_02.png" alt="non-deterministic transition" class="custom-align-center-img" />
<em class="custom-caption">&lt;모델 수준에서 비결정성의 제거&gt;<br />
guard의 검사 범위 구분, 채널 동기화 committed / urgent location, invariant(그림에는 나와있지 않음) 등을 사용하여 비결정성을 제거할 수 있다.</em></p>

<p>따라서 필자는 비결정성을 구현하는 대신, 앞의 1번 항목과 같이 모델을 제한하고자 한다. 방법은 비결정성이 없도록 프로그램 모델을 구현하는 것이다. (아까도 말했지만 환경 모델은 해당되지 않는다. 환경 모델은 비결정성을 많이 둘수록 더 포괄적인 검증이 가능하게 된다.) 그렇지만 어떻게 비결정성이 없도록 모델을 구현할 수 있을까? 여러 전이 사이의 guard에 겹치는 구간을 없도록 하고, 채널이나 invariant, committed/urgent 기능들을 사용하여 시간적 비결정성도 없게 하는 등의 가이드라인이 제시될 수 있다. 아니면 모델을 파싱하는 과정에서 이러한 조건을 만족하도록 모델을 구현했는지 검사하는 기능을 넣을 수도 있겠다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/TCTL.png" alt="TCTL" class="custom-align-center-img" />
<em class="custom-caption">&lt;TCTL 검증의 검사 조건&gt;<br />
A 검증이 참이기 위해서는 모든 가능한 트레이스에 대해 참이어야 하고, E 검증이 참이려면 그러한 조건이 만족하는 트레이스가 하나 이상 존재해야 한다.<br />
[출처 : UPPAAL Tutorial, <a href="http://people.cs.aau.dk/~adavid/publications/21-tutorial.pdf">http://people.cs.aau.dk/~adavid/publications/21-tutorial.pdf</a>]</em></p>

<p>정형 검증에 대해서는 비결정성을 내포하고 있는 의미론을 결정적 모델로 구현을 하더라도 일부는 정형적으로 보장이 가능하다. UPPAAL에서는 TCTL(Timed Computation Tree Logic) 문법에 의거한 검증 식이 주어지는데, 크게 A 검증과 E 검증이 존재한다. A는 모든 트레이스에 대해~ 라는 의미고 E는 어떤 하나 이상의 트레이스에 대해~ 라는 의미이다. 다시 말해서 A 검증은 모든 트레이스에서 조건이 만족해야 참이고, E 검증은 조건이 만족하는 트레이스가 하나라도 있으면 참이 된다. A 검증으로 검증된 조건은 모든 트레이스에서 만족하게 되는데, 결정적인 트레이스는 비결정적인 트레이스의 부분집합(subset)이므로, 결정적으로 구현하더라도 여전히 조건이 만족하게 된다. 반면 E 검증으로 검증된 조건은 그 조건을 만족하는 트레이스가 결정적 트레이스에서 존재하지 않을 수 있으므로 결정적으로 구현했을 때 그 조건이 만족하지 않을 수 있다. 요약하면 A 검증은 비결정적인 의미론을 결정적으로 구현하더라도 여전히 정형적으로 보장된다.</p>

<h2 id="다중-태스크">다중 태스크</h2>

<p>여기서 말하는 다중 태스크의 의미는 컴퓨터에서 여러 개의 스레드나 프로세스를 의미하는 것이 아니고, 하나 이상의 타임드 오토마타로 구성된 네트워크를 의미한다. 좀 더 엄밀히 정의하자면, 프로그램 템플릿이 하나 이상의 인스턴스로 구성된 것을 의미한다. 현재는 프로그램 템플릿이 하나인 것만 지원하고 있으나 필연적으로 다중 태스크를 지원해야 할 것이다. 다중 태스크를 지원하기 위해서 주로 신경써야 할 부분은 태스크 간 실행 우선순위와 다음 항목에서 얘기할 채널 처리 문제다.
UPPAAL2PLC는 single thread로 동작하는 프로그램을 생성한다. 따라서 태스크가 여러 개인 경우 순차적으로 어떤 태스크부터 처리할지 결정해야 한다. 설정 파일에 정의된 task 태그의 순서대로 실행하는 것으로 구현할 예정이다.</p>

<h2 id="채널-처리">채널 처리</h2>

<p>다중 태스크를 지원하게 되면 필연적으로 채널도 구현해야 한다. 채널은 그 종류도 다양하고 그 종류에 따라 구현 방법이 다르다. 채널 종류인 일반, urgent, broadcast와 UPPAAL2PLC에서 특별히 정의하는 <code class="highlighter-rouge">dataExchanged</code> 각각에 대해 구현 방법을 설명할 것이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/channel_01.png" alt="channel 1" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/channel_02.png" alt="channel 2" class="custom-align-center-img" />
<em class="custom-caption">&lt;채널 동기화 시에 update 수행 순서&gt;<br />
채널을 송신하는 쪽(! 기호)의 update가 먼저 수행된다. 위 그림의 경우 채널 동기화가 수행되면 x의 값은 2가 된다.</em></p>

<p>일반 채널은 송신자와 수신자가 1:1로 결정된다. 송신자가 해당 채널을 출력할 준비(guard 조건이나 목적지 location의 invariant 조건 등)가 되었을 때 똑같이 해당 채널을 입력받을 준비가 되어있는 태스크들 중 하나를 선택해서 동시에 전이를 수행한다. 동시에 수행되므로 출력 채널의 update와 입력 채널의 update의 실행 순서가 애매한데, UPPAAL에서는 출력 채널의 update를 먼저 실행하고 입력 채널의 update를 실행하는 것으로 보인다. 일반 채널을 구현하기 위해서는 각 채널마다 참조되는 태스크와 location, transition들을 리스트로 유지해놓는 것이 편할 것이다.</p>

<p>urgent 채널은 송신자와 수신자가 1:1로 결정되는 것은 일반 채널과 같지만, 송신자와 수신자의 해당 채널을 가진 전이가 모두 준비되었을 경우 그 시점에서 시간이 흐르지 않은 시점 내에 반드시 해당 전이가 일어나야 한다. 준비된 시점부터 전이가 일어나는 시점 사이에 시간은 흐르지 않지만 그 동안에 다른 동작은 일어날 수 있다. 그 동작으로 인해 urgent 채널이 있는 전이의 guard가 바뀌어서 전이가 disable되면 해당 전이는 동작하지 않을 수 있다. 구현 관점에서는 앞에서 결정적 동작으로 구현한다고 하였으므로, 일반 채널도 조건이 만족하면 즉시 전이를 수행할 것이니까 urgent 채널과 일반 채널은 동일하게 구현하면 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_01.png" alt="broadcast_channel 1" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_02.png" alt="broadcast_channel 2" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_03.png" alt="broadcast_channel 3" class="custom-align-center-img" />
<em class="custom-caption">&lt;broadcast 채널의 update 실행 순서&gt;<br />
먼저 송신하는 쪽의 update가 수행되고, System declarations에 정의된 템플릿 순서대로 update가 수행된다. 위 그림의 경우 채널 동기화가 수행되고 나면 x의 값은 3이 된다. (위에서부터 아래 순서대로 정의된 경우)</em></p>

<p>broadcast 채널은 송신자와 수신자가 1:n으로 결정된다. n은 0일수도 있으며, 채널의 송신자가 준비되어 채널을 출력할 때 모든 준비된 채널 수신자가 동시에 전이를 수행한다. 역시 update의 실행 순서가 애매한데, 우선 송신자의 update가 먼저 실행되고 수신자들의 update가 순차적으로 실행된다. 실행 순서는 System declarations에 정의된 순서 대로다. 구현 관점에서는 준비된 전이에 broadcast 채널이 있는 경우 우선 동작시키고 그 채널의 수신자들을 모두 검색해 준비된 전이를 모두 수행하는 것으로 구현한다.</p>

<p><code class="highlighter-rouge">dataExchanged</code> 채널은 주기가 시작되었음을 알리는 채널이다. 모든 태스크는 주기가 시작되었을 때 현재 location에서 <code class="highlighter-rouge">dataExchanged</code> 채널을 수신하는 전이가 있다면 그것을 1회 먼저 실행하도록 구현된다. 또한 한 주기 내에서 태스크 당 dataExchanged 채널은 1회 수신될 수 있도록 구현해야 한다.</p>

<h2 id="invariant">invariant</h2>

<p>Invariant는 어떤 location에서 정의되며 태스크가 그 상태에 있을 때 반드시 만족해야 하는 조건을 의미한다. clock 변수 등의 변화로 인해 현재 location에서 더 이상 invariant를 만족하지 않게 될 경우 그 전에 location을 벗어나야 한다. 벗어날 수 없으면 그 invariant를 만족하지 않게 하는 수행, 시간의 흐름이나 변수의 변경이 불가능하다. 이렇게 invariant를 더 이상 만족하지 않을 수밖에 없는데 벗어날 조건이 만족하는 전이가 없으면 deadlock이 발생하게 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/system_template.png" alt="system template" class="custom-align-center-img" />
<em class="custom-caption">&lt;시스템 템플릿에 쓰인 invariant (tickClock &lt;= PERIOD)&gt;<br />
invariant가 없다면 전이 조건 tickClock &gt;= PERIOD가 참이 되었다고 해도 WaitStep에 계속 머무를 수 있다. 이러한 동작을 제한하기 위해 invariant를 도입하면 tickClock 값이 PERIOD 값이 되는 순간 전이가 일어나도록 모델링할 수 있다.</em></p>

<p>구현 관점에서 invariant는 정말 복잡하다. 어떤 전이를 수행하고자 할 때, 그 전이의 guard나 채널 외에도 invariant 계산량이 상당하다. 우선 정확히 invariant를 계산하기 위해서는 update를 먼저 수행해야 한다. update에서 변경하는 값이 invariant에서 검사하는 조건 값과 의존성이 있을수도 있기 때문이다. 따라서 update를 임시적으로 수행해야 하는데, 이 때 전역변수와 해당 템플릿의 지역변수를 백업하고, update를 수행한 후 invariant를 검사하고 다시 백업한 데이터를 돌려놔야 하기 때문이다. 또한 하나의 전이의 수행 조건을 검사하기 위해 검사할 invariant의 양도 상당하다. 간단하게 구현한다면 전이가 수행되었을 상태를 기준으로 전체 태스크의 현재 location에 대한 invariant를 검사해야 한다. 그게 아니면 전이의 update와 의존성이 있는 invariant만 찾아서 검사해보는 것도 생각해볼 수 있다.</p>

<h2 id="declarations-지원-문법">Declarations 지원 문법</h2>

<p>여기에서 제시하는 것들은 지금은 구현되어있지 않지만 그 구현 여부가 타임드 오토마타 의미론 구현에 크게 영향이 없는 것들이다. UPPAAL에서 지원하는 부수적인 기능들이며 대부분 parsing &amp; generation 알고리즘을 변경하여 구현이 가능하다.</p>

<ul>
  <li>range 타입 변수</li>
  <li>변수를 콤마로 이어서 선언</li>
  <li>템플릿 파라미터</li>
  <li>select</li>
  <li>기타 등등</li>
</ul>

<h2 id="urgent--committed-location">urgent &amp; committed location</h2>

<p>location에도 채널처럼 타입이 존재한다. 일반 location은 별도의 제약이 없는 일반적인 location이며 의미론에서는 조건이 만족하면 이 상태에서 계속 머무를 수 있다. urgent location은 이 location에 들어온 시점부터 나가는 시점까지 시간이 흐르지 않아야 하는 것을 의미한다. 차이점은 urgent location은 단지 시간이 흐르지만 않으면 될 뿐이지만 committed location은 다른 태스크의 전이보다 반드시 해당 location에서 빠져나가는 전이가 먼저 수행되어야 한다는 것이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/urgent_location.png" alt="urgent location" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/committed_location.png" alt="committed location" class="custom-align-center-img" />
<em class="custom-caption">&lt;urgent location과 committed location&gt;</em></p>

<p>위 그림의 경우 가능한 트레이스는 다음과 같다.</p>
<ul>
  <li>(U0, C0) -&gt; (U1, C0) -&gt; (U1, C1) -&gt; (U1, C2) -&gt; (U2, C2)</li>
  <li>(U0, C0) -&gt; (U0, C1) -&gt; (U0, C2) -&gt; (U1, C2) -&gt; (U2, C2)</li>
  <li>(U0, C0) -&gt; (U1, C0) -&gt; (U2, C0) -&gt; (U2, C1) -&gt; (U2, C2)</li>
</ul>

<p>C1 상태로 진입했다면 다음 상태는 반드시 C2 상태여야 하며, 모든 경우에서 U1 상태나 C1 상태로 진입한 순간부터 둘 모두 U2, C2 상태가 될 때까지 시간 흐름이 없다. (수행 시간이 0이다, 즉 같은 주기 내에 반드시 실행되어야 한다.)</p>

<p>구현 관점에서는 결정적 동작으로 구현하였을 때 일반 location과 urgent location은 동작이 동일하다. 반면 committed location은 우선순위를 높게 두어서 별도로 처리해야 한다. 현재 시점에서 가능한 전이를 파악하기 전에 현재 committed location에 들어가 있는 태스크가 있다면 해당 태스크를 먼저 실행하도록 구현하면 된다.</p>]]></content><author><name>khlee</name></author><category term="MDD" /><summary type="html"><![CDATA[지난 글에서 소개한 UPPAAL2PLC는 아직 개선해야 할 점이 남아있다. 현재 UPPAAL2PLC는 UPPAAL에서 모델링 가능한 모든 모델을 지원하지 못하고 제한적으로 지원한다. 예를 들어 태스크는 하나만 있어야 하고, 비결정적 전이를 올바르게 구현하지 않는다는 제한사항이 있다. 이번 글에서는 UPPAAL2PLC의 추후 개선 방향과, 정형 모델과 실제 시스템의 차이로 인한 상호 변환의 어려움에 대해 기술할 것이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>