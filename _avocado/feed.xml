<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-15T13:08:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lklab</title><subtitle>Reality and Theory</subtitle><author><name>khlee</name></author><entry><title type="html">UPPAAL2PLC 개선작업</title><link href="http://localhost:4000/blog/Improving-UPPAAL2PLC/" rel="alternate" type="text/html" title="UPPAAL2PLC 개선작업" /><published>2017-07-26T00:00:00+09:00</published><updated>2017-07-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/Improving-UPPAAL2PLC</id><content type="html" xml:base="http://localhost:4000/blog/Improving-UPPAAL2PLC/"><![CDATA[<p><a href="https://lklab.github.io/blog/blog/UPPAAL2PLC/">지난 글</a>에서 소개한 UPPAAL2PLC는 아직 개선해야 할 점이 남아있다. 현재 UPPAAL2PLC는 UPPAAL에서 모델링 가능한 모든 모델을 지원하지 못하고 제한적으로 지원한다. 예를 들어 태스크는 하나만 있어야 하고, 비결정적 전이를 올바르게 구현하지 않는다는 제한사항이 있다.
이번 글에서는 UPPAAL2PLC의 추후 개선 방향과, 정형 모델과 실제 시스템의 차이로 인한 상호 변환의 어려움에 대해 기술할 것이다.</p>

<h2 id="시간의-연속성과-동시성-가설">시간의 연속성과 동시성 가설</h2>

<p>UPPAAL에서 사용하는 정형 언어인 타임드 오토마타의 의미론(Semantics)에서는 시간 값, 즉 clock 변수의 값은 연속적이다. 그러나 컴퓨터 시스템에서는 시간성을 구현하기 위해서 일정 주기 단위로 반복 수행하는 방법을 사용하는데, 이 경우 각 주기마다 시간은 동일한 것으로 표현되어 이산적인 시간 값을 갖게 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/continuous_time_discrete_time.png" alt="continuous time and discrete time" class="custom-align-center-img" />
<em class="custom-caption">&lt;연속적인 실제 시간과 이산적인 시간&gt;<br />
실제 시간은 각 시점마다 연속적인 실수 값으로 표현되지만 이산적인 시간은 한 주기 내에서 동일한 값으로 표현된다.</em></p>

<p>이를 해결하기 위해 주기를 짧게 해서 이산적인 시간 값으로 최대한 연속적인 시간을 흉내 내게 하는 방법이 있을 것이다. 하지만 이것은 엄격한 의미가 중요시되는 정형 기법에서는 허용되지 않는다. 이러한 차이로 인해 모델과 실제 동작 사이에 차이가 생길 수 있기 때문이다.
그렇다면 타임드 오토마타의 의미론을 약간 수정하면 어떨까? 연속적인 시간 값을 사용하지 않는 것이다. 사실 이것을 위한 준비가 이미 되어 있다. 지난 글에서 UPPAAL에서 모델을 개발할 때 반드시 포함해야 하는 템플릿, 시스템 템플릿이 있다고 했다. 이 템플릿에서 연속적인 clock 값을 이용하여 주기적으로 <code class="highlighter-rouge">dataExchanged</code> 채널을 출력한다. 이 채널의 출력 주기가 바로 이산적인 시간을 의미하게 된다. 프로그램 템플릿에서는 이 채널을 수신하여 이산적인 시간을 모델링할 수 있다. 또한, 주기 clock 값의 배수만 사용하는 것으로 제한해도 이산적인 시간을 표현하는 것이 된다. 단, 환경 템플릿에서는 이 제한을 지키지 않아도 된다. 더 좋은 검증을 위해서는 환경 템플릿에 한해 이러한 제한을 지키지 않는 것이 좋다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/system_template.png" alt="system template" class="custom-align-center-img" />
<em class="custom-caption">&lt;시스템 템플릿&gt;<br />
주기적으로 dataExchanged 채널을 출력한다. 이 채널을 받을 때마다 시간 값이 주기만큼 증가한다고 모델링한다.</em></p>

<p>동시성 가설은 어떤 실행이 한 순간에 완료된다고 가정하는 것이다. 타임드 오토마타의 의미론에서는 동시성 가설이 적용되어, 전이라던가 guard 검사, update 수행 등이 모두 시간의 흐름 없이 진행된다. 또한 urgent, committed location 등과 같이 아예 의미적으로 시간이 흐르지 않고 바로 다음 상태로 전이되어야 하는 상태도 존재한다. 이것은 앞에서 언급한 모델에 이산적인 시간을 도입하는 것으로 어느 정도 해결된다. 한 주기 내에서는 시간이 동일한 것으로 표현되므로, 그 주기 내에 실행되는 것들은 모두 실행 시간이 없는 것이 된다. 다만 로드가 심해서 한 주기 동안 수행되어야 할 모든 일을 주기 내에 마치지 못하면 왜곡이 발생한다. 이전 주기에 시작되어 다음 주기에 끝난 태스크는 그 수행 시간이 이미 한 주기 만큼의 시간이 되기 때문이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" alt="concurrency hypothesis" class="custom-align-center-img" />
<em class="custom-caption">&lt;동시성 가설의 구현&gt;<br />
이산적인 시간 표현에서는 한 주기 내에 태스크가 실행되고 종료되면 그 수행 시간이 0인 것으로 표현된다. 그러나 주기를 넘어가게 되면 수행 시간이 한 주기 만큼의 시간이 된다.</em></p>

<p>보다 근본적으로 모델의 시간을 구현하기 위해선 엄밀한 주기성이 필수적이다. 즉 주기가 실제 시간으로 얼마나 시간을 정확히 맞추느냐는 것이다. 따라서 실시간 성능이 좋은 플랫폼 상에서만 모델의 시간이 실제 시간으로 잘 구현될 수 있다.
모델의 시간은 주기의 횟수로 구현된다고 생각하면 의미적으로 정확하다. 예를 들어 모델 시간으로 3을 주기라고 생각한다면, “clock 값이 0에서 12까지 증가하는 동안”이라는 의미는 구현 관점에서 “4번의 주기가 수행되는 동안”과 동일한 의미가 된다.
정리해서, UPPAAL에서 <code class="highlighter-rouge">dataExchanged</code> 채널과 주기 클럭의 배수만 사용하도록 제한하고, 한 주기 내에 필요한 모든 작업이 반드시 완료되면 시간의 연속성과 동시성 가설 문제는 해결될 수 있다.</p>

<h2 id="비결정적-전이">비결정적 전이</h2>

<p>타임드 오토마타의 의미론에서는, 현재 상태에서 채널이나 guard 조건 등을 만족한 전이가 여러 개 있을 경우 그것들 중 하나를 랜덤으로 선택하여 전이를 수행하거나, invariant 등의 조건이 만족한다면 아예 전이가 일어나지 않을 수 있다. 즉, 수행 트레이스를 정확히 예측할 수 없는 비결정성이 존재한다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/non-deterministic_transition_01.png" alt="non-deterministic transition" class="custom-align-center-img" />
<em class="custom-caption">&lt;비결정적인 전이가 일어날 수 있는 예&gt;<br />
value의 값이 150이라면, 초기 Initial 상태에서 다음 상태에 L0이나 L1 또는 L2 상태가 될 수 있고 그대로 Initial 상태에 머무를 수도 있다.</em></p>

<p>이러한 특징을 구현하기 위해서는 현재 상태에서 모든 가능한 다음 상태를 리스트로 구한 다음 그들 중 하나를 랜덤함수를 이용하여 선택하는 방법이 사용될 수 있다. 그러나 비결정성이 반드시 필요한가? 게임 등에서는 여러분의 장비를 강화할 때 일정 확률로 부서지게 하는 기능에는 사용될 수 있겠지만 산업 장치들을 제어하는 프로그램에서 어떻게 실행될지 예측하지 못하는 기능이 효용성이 있을지는 생각해 봐야 한다. 물론, 타임드 오토마타의 시멘틱스를 온전하게 구현하면 정형 검증에 대한 보장을 가져갈 수 있지만, 쓸모 없는 기능을 위해 계산 시간을 낭비하는 것도 피해야 할 요소이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/non-deterministic_transition_02.png" alt="non-deterministic transition" class="custom-align-center-img" />
<em class="custom-caption">&lt;모델 수준에서 비결정성의 제거&gt;<br />
guard의 검사 범위 구분, 채널 동기화 committed / urgent location, invariant(그림에는 나와있지 않음) 등을 사용하여 비결정성을 제거할 수 있다.</em></p>

<p>따라서 필자는 비결정성을 구현하는 대신, 앞의 1번 항목과 같이 모델을 제한하고자 한다. 방법은 비결정성이 없도록 프로그램 모델을 구현하는 것이다. (아까도 말했지만 환경 모델은 해당되지 않는다. 환경 모델은 비결정성을 많이 둘수록 더 포괄적인 검증이 가능하게 된다.) 그렇지만 어떻게 비결정성이 없도록 모델을 구현할 수 있을까? 여러 전이 사이의 guard에 겹치는 구간을 없도록 하고, 채널이나 invariant, committed/urgent 기능들을 사용하여 시간적 비결정성도 없게 하는 등의 가이드라인이 제시될 수 있다. 아니면 모델을 파싱하는 과정에서 이러한 조건을 만족하도록 모델을 구현했는지 검사하는 기능을 넣을 수도 있겠다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/TCTL.png" alt="TCTL" class="custom-align-center-img" />
<em class="custom-caption">&lt;TCTL 검증의 검사 조건&gt;<br />
A 검증이 참이기 위해서는 모든 가능한 트레이스에 대해 참이어야 하고, E 검증이 참이려면 그러한 조건이 만족하는 트레이스가 하나 이상 존재해야 한다.<br />
[출처 : UPPAAL Tutorial, <a href="http://people.cs.aau.dk/~adavid/publications/21-tutorial.pdf">http://people.cs.aau.dk/~adavid/publications/21-tutorial.pdf</a>]</em></p>

<p>정형 검증에 대해서는 비결정성을 내포하고 있는 의미론을 결정적 모델로 구현을 하더라도 일부는 정형적으로 보장이 가능하다. UPPAAL에서는 TCTL(Timed Computation Tree Logic) 문법에 의거한 검증 식이 주어지는데, 크게 A 검증과 E 검증이 존재한다. A는 모든 트레이스에 대해~ 라는 의미고 E는 어떤 하나 이상의 트레이스에 대해~ 라는 의미이다. 다시 말해서 A 검증은 모든 트레이스에서 조건이 만족해야 참이고, E 검증은 조건이 만족하는 트레이스가 하나라도 있으면 참이 된다. A 검증으로 검증된 조건은 모든 트레이스에서 만족하게 되는데, 결정적인 트레이스는 비결정적인 트레이스의 부분집합(subset)이므로, 결정적으로 구현하더라도 여전히 조건이 만족하게 된다. 반면 E 검증으로 검증된 조건은 그 조건을 만족하는 트레이스가 결정적 트레이스에서 존재하지 않을 수 있으므로 결정적으로 구현했을 때 그 조건이 만족하지 않을 수 있다. 요약하면 A 검증은 비결정적인 의미론을 결정적으로 구현하더라도 여전히 정형적으로 보장된다.</p>

<h2 id="다중-태스크">다중 태스크</h2>

<p>여기서 말하는 다중 태스크의 의미는 컴퓨터에서 여러 개의 스레드나 프로세스를 의미하는 것이 아니고, 하나 이상의 타임드 오토마타로 구성된 네트워크를 의미한다. 좀 더 엄밀히 정의하자면, 프로그램 템플릿이 하나 이상의 인스턴스로 구성된 것을 의미한다. 현재는 프로그램 템플릿이 하나인 것만 지원하고 있으나 필연적으로 다중 태스크를 지원해야 할 것이다. 다중 태스크를 지원하기 위해서 주로 신경써야 할 부분은 태스크 간 실행 우선순위와 다음 항목에서 얘기할 채널 처리 문제다.
UPPAAL2PLC는 single thread로 동작하는 프로그램을 생성한다. 따라서 태스크가 여러 개인 경우 순차적으로 어떤 태스크부터 처리할지 결정해야 한다. 설정 파일에 정의된 task 태그의 순서대로 실행하는 것으로 구현할 예정이다.</p>

<h2 id="채널-처리">채널 처리</h2>

<p>다중 태스크를 지원하게 되면 필연적으로 채널도 구현해야 한다. 채널은 그 종류도 다양하고 그 종류에 따라 구현 방법이 다르다. 채널 종류인 일반, urgent, broadcast와 UPPAAL2PLC에서 특별히 정의하는 <code class="highlighter-rouge">dataExchanged</code> 각각에 대해 구현 방법을 설명할 것이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/channel_01.png" alt="channel 1" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/channel_02.png" alt="channel 2" class="custom-align-center-img" />
<em class="custom-caption">&lt;채널 동기화 시에 update 수행 순서&gt;<br />
채널을 송신하는 쪽(! 기호)의 update가 먼저 수행된다. 위 그림의 경우 채널 동기화가 수행되면 x의 값은 2가 된다.</em></p>

<p>일반 채널은 송신자와 수신자가 1:1로 결정된다. 송신자가 해당 채널을 출력할 준비(guard 조건이나 목적지 location의 invariant 조건 등)가 되었을 때 똑같이 해당 채널을 입력받을 준비가 되어있는 태스크들 중 하나를 선택해서 동시에 전이를 수행한다. 동시에 수행되므로 출력 채널의 update와 입력 채널의 update의 실행 순서가 애매한데, UPPAAL에서는 출력 채널의 update를 먼저 실행하고 입력 채널의 update를 실행하는 것으로 보인다. 일반 채널을 구현하기 위해서는 각 채널마다 참조되는 태스크와 location, transition들을 리스트로 유지해놓는 것이 편할 것이다.</p>

<p>urgent 채널은 송신자와 수신자가 1:1로 결정되는 것은 일반 채널과 같지만, 송신자와 수신자의 해당 채널을 가진 전이가 모두 준비되었을 경우 그 시점에서 시간이 흐르지 않은 시점 내에 반드시 해당 전이가 일어나야 한다. 준비된 시점부터 전이가 일어나는 시점 사이에 시간은 흐르지 않지만 그 동안에 다른 동작은 일어날 수 있다. 그 동작으로 인해 urgent 채널이 있는 전이의 guard가 바뀌어서 전이가 disable되면 해당 전이는 동작하지 않을 수 있다. 구현 관점에서는 앞에서 결정적 동작으로 구현한다고 하였으므로, 일반 채널도 조건이 만족하면 즉시 전이를 수행할 것이니까 urgent 채널과 일반 채널은 동일하게 구현하면 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_01.png" alt="broadcast_channel 1" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_02.png" alt="broadcast_channel 2" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/broadcast_channel_03.png" alt="broadcast_channel 3" class="custom-align-center-img" />
<em class="custom-caption">&lt;broadcast 채널의 update 실행 순서&gt;<br />
먼저 송신하는 쪽의 update가 수행되고, System declarations에 정의된 템플릿 순서대로 update가 수행된다. 위 그림의 경우 채널 동기화가 수행되고 나면 x의 값은 3이 된다. (위에서부터 아래 순서대로 정의된 경우)</em></p>

<p>broadcast 채널은 송신자와 수신자가 1:n으로 결정된다. n은 0일수도 있으며, 채널의 송신자가 준비되어 채널을 출력할 때 모든 준비된 채널 수신자가 동시에 전이를 수행한다. 역시 update의 실행 순서가 애매한데, 우선 송신자의 update가 먼저 실행되고 수신자들의 update가 순차적으로 실행된다. 실행 순서는 System declarations에 정의된 순서 대로다. 구현 관점에서는 준비된 전이에 broadcast 채널이 있는 경우 우선 동작시키고 그 채널의 수신자들을 모두 검색해 준비된 전이를 모두 수행하는 것으로 구현한다.</p>

<p><code class="highlighter-rouge">dataExchanged</code> 채널은 주기가 시작되었음을 알리는 채널이다. 모든 태스크는 주기가 시작되었을 때 현재 location에서 <code class="highlighter-rouge">dataExchanged</code> 채널을 수신하는 전이가 있다면 그것을 1회 먼저 실행하도록 구현된다. 또한 한 주기 내에서 태스크 당 dataExchanged 채널은 1회 수신될 수 있도록 구현해야 한다.</p>

<h2 id="invariant">invariant</h2>

<p>Invariant는 어떤 location에서 정의되며 태스크가 그 상태에 있을 때 반드시 만족해야 하는 조건을 의미한다. clock 변수 등의 변화로 인해 현재 location에서 더 이상 invariant를 만족하지 않게 될 경우 그 전에 location을 벗어나야 한다. 벗어날 수 없으면 그 invariant를 만족하지 않게 하는 수행, 시간의 흐름이나 변수의 변경이 불가능하다. 이렇게 invariant를 더 이상 만족하지 않을 수밖에 없는데 벗어날 조건이 만족하는 전이가 없으면 deadlock이 발생하게 된다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/system_template.png" alt="system template" class="custom-align-center-img" />
<em class="custom-caption">&lt;시스템 템플릿에 쓰인 invariant (tickClock &lt;= PERIOD)&gt;<br />
invariant가 없다면 전이 조건 tickClock &gt;= PERIOD가 참이 되었다고 해도 WaitStep에 계속 머무를 수 있다. 이러한 동작을 제한하기 위해 invariant를 도입하면 tickClock 값이 PERIOD 값이 되는 순간 전이가 일어나도록 모델링할 수 있다.</em></p>

<p>구현 관점에서 invariant는 정말 복잡하다. 어떤 전이를 수행하고자 할 때, 그 전이의 guard나 채널 외에도 invariant 계산량이 상당하다. 우선 정확히 invariant를 계산하기 위해서는 update를 먼저 수행해야 한다. update에서 변경하는 값이 invariant에서 검사하는 조건 값과 의존성이 있을수도 있기 때문이다. 따라서 update를 임시적으로 수행해야 하는데, 이 때 전역변수와 해당 템플릿의 지역변수를 백업하고, update를 수행한 후 invariant를 검사하고 다시 백업한 데이터를 돌려놔야 하기 때문이다. 또한 하나의 전이의 수행 조건을 검사하기 위해 검사할 invariant의 양도 상당하다. 간단하게 구현한다면 전이가 수행되었을 상태를 기준으로 전체 태스크의 현재 location에 대한 invariant를 검사해야 한다. 그게 아니면 전이의 update와 의존성이 있는 invariant만 찾아서 검사해보는 것도 생각해볼 수 있다.</p>

<h2 id="declarations-지원-문법">Declarations 지원 문법</h2>

<p>여기에서 제시하는 것들은 지금은 구현되어있지 않지만 그 구현 여부가 타임드 오토마타 의미론 구현에 크게 영향이 없는 것들이다. UPPAAL에서 지원하는 부수적인 기능들이며 대부분 parsing &amp; generation 알고리즘을 변경하여 구현이 가능하다.</p>

<ul>
  <li>range 타입 변수</li>
  <li>변수를 콤마로 이어서 선언</li>
  <li>템플릿 파라미터</li>
  <li>select</li>
  <li>기타 등등</li>
</ul>

<h2 id="urgent--committed-location">urgent &amp; committed location</h2>

<p>location에도 채널처럼 타입이 존재한다. 일반 location은 별도의 제약이 없는 일반적인 location이며 의미론에서는 조건이 만족하면 이 상태에서 계속 머무를 수 있다. urgent location은 이 location에 들어온 시점부터 나가는 시점까지 시간이 흐르지 않아야 하는 것을 의미한다. 차이점은 urgent location은 단지 시간이 흐르지만 않으면 될 뿐이지만 committed location은 다른 태스크의 전이보다 반드시 해당 location에서 빠져나가는 전이가 먼저 수행되어야 한다는 것이다.</p>

<p><img src="/blog/assets/post/17-07-26-UPPAAL2PLC/committed_location.png" alt="committed location" class="custom-align-center-img" />
<img src="/blog/assets/post/17-07-26-UPPAAL2PLC/urgent_location.png" alt="urgent location" class="custom-align-center-img" />
<em class="custom-caption">&lt;urgent location과 committed location&gt;</em></p>

<p>위 그림의 경우 가능한 트레이스는 다음과 같다.</p>
<ul>
  <li>(U0, C0) -&gt; (U1, C0) -&gt; (U1, C1) -&gt; (U1, C2) -&gt; (U2, C2)</li>
  <li>(U0, C0) -&gt; (U0, C1) -&gt; (U0, C2) -&gt; (U1, C2) -&gt; (U2, C2)</li>
  <li>(U0, C0) -&gt; (U1, C0) -&gt; (U2, C0) -&gt; (U2, C1) -&gt; (U2, C2)</li>
</ul>

<p>C1 상태로 진입했다면 다음 상태는 반드시 C2 상태여야 하며, 모든 경우에서 U1 상태나 C1 상태로 진입한 순간부터 둘 모두 U2, C2 상태가 될 때까지 시간 흐름이 없다. (수행 시간이 0이다, 즉 같은 주기 내에 반드시 실행되어야 한다.)</p>

<p>구현 관점에서는 결정적 동작으로 구현하였을 때 일반 location과 urgent location은 동작이 동일하다. 반면 committed location은 우선순위를 높게 두어서 별도로 처리해야 한다. 현재 시점에서 가능한 전이를 파악하기 전에 현재 committed location에 들어가 있는 태스크가 있다면 해당 태스크를 먼저 실행하도록 구현하면 된다.</p>]]></content><author><name>khlee</name></author><category term="MDD" /><summary type="html"><![CDATA[지난 글에서 소개한 UPPAAL2PLC는 아직 개선해야 할 점이 남아있다. 현재 UPPAAL2PLC는 UPPAAL에서 모델링 가능한 모든 모델을 지원하지 못하고 제한적으로 지원한다. 예를 들어 태스크는 하나만 있어야 하고, 비결정적 전이를 올바르게 구현하지 않는다는 제한사항이 있다. 이번 글에서는 UPPAAL2PLC의 추후 개선 방향과, 정형 모델과 실제 시스템의 차이로 인한 상호 변환의 어려움에 대해 기술할 것이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-26-UPPAAL2PLC/concurrency_hypothesis.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Automated PLC Application Generation Solution from UPPAAL Model : UPPAAL2PLC</title><link href="http://localhost:4000/blog/UPPAAL2PLC/" rel="alternate" type="text/html" title="Automated PLC Application Generation Solution from UPPAAL Model : UPPAAL2PLC" /><published>2017-07-24T00:00:00+09:00</published><updated>2017-07-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/UPPAAL2PLC</id><content type="html" xml:base="http://localhost:4000/blog/UPPAAL2PLC/"><![CDATA[<h2 id="소개">소개</h2>

<p>개인적으로 개발 중인 UPPAAL2PLC의 1차 버전을 github에 릴리즈했다.</p>

<p>(repo : <a href="https://github.com/lklab/Uppaal2PLC">https://github.com/lklab/Uppaal2PLC</a>)</p>

<p>UPPAAL2PLC는 작년에 수업 프로젝트로 시작해서 개인적으로 계속 진행하고 있던 프로젝트로, 소프트웨어 모델링 및 검증 툴인 <a href="https://uppaal.org/">UPPAAL</a>을 통해 개발된 타임드 오토마타 모델을 PLC(Programmable Logic Controller)에서 동작하는 프로그램으로 자동 변환해주는 기능을 한다.</p>

<p>이 글에서는 UPPAAL2PLC를 포함하는 MDD(Model Driven-Development)의 개념과 UPPAAL2PLC를 사용하여 검증된 프로그램을 개발하는 예시를 다룰 것이다.</p>

<p>정형 기법(Formal Method)은 소프트웨어가 만족해야 하는 속성을 수학적인 증명을 통해 검증하는 방법이다. 이를 위해 검증이 가능하도록 수학적인 장치가 마련된 언어를 소프트웨어를 명세하는 데 사용하는데, 이것이 정형 언어(Formal Language)이다. 정형 언어로 기술된 소프트웨어는 비록 검증은 가능하더라도, 실제 프로그램으로 동작하기 위해서는 C나 자바 등의 개발 언어로 재작성 되어야 한다.</p>

<p>정형 언어와 개발 언어의 변환이 비정형적(informal)으로 이루어지면, 정형 기법을 통해 검증된 속성이 개발 언어에서도 만족한다는 보장을 할 수 없게 된다. 따라서 두 언어 사이의 변환을 자동화하는 방법으로 어느 정도 정형성을 확보하려는 노력을 하게 되는데, 이것이 바로 MDD다. 물론 완전한 정형적 보장을 위해서는 자동 변환 과정에 대한 검증도 필요하다.</p>

<p>UPPAAL2PLC는 정형 언어 타임드 오토마타(Timed Automata)로부터 C 코드로 변환 후 컴파일하여 PLC 응용으로 생성한다. 타임드 오토마타의 개발 및 검증 툴로 UPPAAL을 사용한다. 또한 PLC 플랫폼이나 응용이 입출력하는 데이터 등을 정의한 설정 파일도 별도 입력으로 받아, 생성된 코드나 응용에 대한 추가 작업 없이 바로 실행이 가능한 응용을 생성한다.</p>

<p>UPPAAL2PLC를 사용하여 PLC 응용을 개발하는 과정은 다음과 같다.</p>
<ol>
  <li>UPPAAL을 사용하여 타겟 시스템 모델링</li>
  <li>UPPAAL을 사용하여 모델 검증 및 모델 수정</li>
  <li>검증된 모델이 정의된 UPPAAL 프로젝트 파일과 설정 파일 준비</li>
  <li>UPPAAL2PLC에 두 파일 입력 후 실행하여 실행파일 생성</li>
</ol>

<p>이 과정에서 개발자가 직접 개입하는 과정은 1번, 3번이고, 나머지는 개발자가 명령을 내리면 UPPAAL 검증기(Verifier)나 UPPAAL2PLC가 자동으로 수행하는 것들이다.
UPPAAL2PLC는 타겟 시스템이 PLC로 한정되어 있는데, 이 때문에 개발자가 개입하는 1번, 3번 과정에서 지켜야 할 규칙이 있다. 이것을 다음 예시를 통해 설명할 것이다.</p>

<h2 id="예시---신호등-시스템">예시 - 신호등 시스템</h2>

<p>먼저 예시로 삼을 시스템을 정의한다. 간단하게 신호등 시스템이다. github에 올라와 있는 예제(<a href="https://github.com/lklab/Uppaal2PLC/tree/master/examples/TrafficLightControl">TrafficLightControl</a>)이기도 하다.
보행자는 버튼을 누를 수 있고 버튼이 눌리면 일정 시간 후에 초록 불이 된다. 그 후에는 버튼 입력과 상관 없이 일정 시간 후에 빨간 불이 되며, 다시 버튼을 누를 경우 그 시점부터 일정 시간 후에 초록 불이 된다.</p>

<h2 id="시스템-모델">시스템 모델</h2>

<p>먼저 UPPAAL을 사용해서 타겟 시스템을 모델링해야 한다. UPPAAL에서는 각 타임드 오토마타의 구조를 정의한 것을 템플릿이라고 하는데, 총 3종류의 템플릿으로 나누어서 모델링해야 한다. 그 종류는 시스템 모델, 환경 모델, 프로그램 모델이다. 시스템 모델은 PLC의 동작 방식을 모델링한 것으로 모든 응용에 대해 반드시 동일하게 포함해야 한다. 다음 그림은 시스템 모델을 나타낸다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/system_model.png" alt="System model" /></p>

<p>PLC는 주기적으로 동일한 로직을 반복 실행한다. 각 로직은 세 가지로 구분된다. 입력, 출력, 계산. 입력은 외부 장치로부터 값을 읽어서 메모리에 저장하는 것이고 출력은 메모리에 저장된 값을 외부 장치에 출력하는 것이다. 계산은 메모리에 저장된 입력 데이터로부터 응용마다 다르게 정의된 로직에 따라 계산된 출력 데이터를 메모리에 저장하는 것이다. 이러한 동작을 모델링한 것이 위의 시스템 모델이다. <code class="highlighter-rouge">tickClock</code>은 주기적인 실행을 모델링하기 위해 도입한 Clock 변수이고, <code class="highlighter-rouge">exchangeData()</code> 함수는 입력과 출력 기능을 수행하는 함수이다. <code class="highlighter-rouge">dataExchanged</code> 채널은 시스템 전체의 모델들에게 입출력 교환이 완료되었음을 알려서 계산을 수행하도록 신호를 주는 역할을 한다.</p>

<p><code class="highlighter-rouge">exchangeData()</code> 함수의 내용을 작성할 때에도 지켜야 할 규칙이 있다. 먼저 다음 그림을 보자.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/exchange_data.png" alt="Exchange data" /></p>

<p>함수 내에서는 앞 글자만 다른 두 변수의 값을 복사하는 것으로 이루어진다. 설명하자면, <code class="highlighter-rouge">p</code>로 시작하는 변수는 프로그램 모델쪽, <code class="highlighter-rouge">e</code>로 시작하는 변수는 환경 모델쪽 변수이다. 이렇게 같은 기능의 변수를 전역 변수 하나로 두어 공유하지 않고 분리하는 이유는 PLC의 동작 특성에 있다. 프로그램 모델은 PLC에서 동작하는 응용을 모델링한 것이고, 환경 모델은 외부 장치들을 모델링한 것이다. 이 예에서는 환경 모델에 신호등, 버튼, 보행자 등이 포함될 수 있을 것이다. PLC 시스템에서는 PLC와 외부 장치가 언제나 통신하여 데이터를 교환하는 것이 아니고 주기적인 시점에서만 데이터 교환이 일어난다. 따라서 전역 변수 하나를 공유하게 되면 이러한 특성이 드러나지 않게 되어, 모델과 실제 프로그램간 차이가 발생하며, 모델에서 검증된 속성이 실제 프로그램에서도 만족함을 보장할 수 없게 된다.</p>

<h2 id="환경-모델">환경 모델</h2>

<p>다음 그림들은 환경 모델이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_1.png" alt="Environment model 1" />
<img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_2.png" alt="Environment model 2" />
<img src="/blog/assets/post/17-07-24-UPPAAL2PLC/env_model_3.png" alt="Environment model 3" /></p>

<p>순서대로 보행자(Pedestrian), 신호등(Light), 버튼(Button) 모델인데, 자세한 내용은 설명하지 않고 동작 방식만 설명하려고 한다. 먼저 보행자 모델은 <code class="highlighter-rouge">push</code> 채널을 통해 버튼 모델에 신호를 보낼 수 있고 그 신호를 받으면 보튼 모델에서는 <code class="highlighter-rouge">eButton</code>, 즉 환경 모델 쪽 버튼 변수의 값을 <code class="highlighter-rouge">true</code>로 바꾼다. 이 값은 주기적인 시점, 즉 <code class="highlighter-rouge">exchangeData()</code> 함수가 호출될 때 프로그램 모델에 넘어갈 것이다. 신호등 모델은 주기적으로 <code class="highlighter-rouge">eLight</code>의 값을 확인하여 <code class="highlighter-rouge">true</code>이면 <code class="highlighter-rouge">Green</code>으로, <code class="highlighter-rouge">false</code>이면 <code class="highlighter-rouge">Red</code>로 상태를 변경한다.</p>

<h2 id="프로그램-모델">프로그램 모델</h2>

<p>이제 프로그램 모델이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/program_model.png" alt="Program model" /></p>

<p>프로그램 모델은 좀 복잡해 보이지만 간단히 말해서 아까 명세한 신호등의 기능을 모델링한 것이라고 보면 된다. 초기의 <code class="highlighter-rouge">LightRed</code> 상태에서 버튼 입력을 확인하고 <code class="highlighter-rouge">true</code>이면 <code class="highlighter-rouge">WAIT_TIME</code> 시간 동안 기다리다가 신호등 초록 불을 켜고(<code class="highlighter-rouge">pLight = true</code>), <code class="highlighter-rouge">GREEN_TIME</code> 시간 동안 기다리다가 다시 빨간 불로 돌아온다.(<code class="highlighter-rouge">pLight = false</code>)</p>

<p>실제로 응용으로 변환될 모델은 프로그램 모델이다. 환경 모델과 시스템 모델은 검증을 위해 필요한 모델들인데, 그렇다고 이들 모델링에 소홀하면 제대로 된 검증이 될 수 없다.
프로그램 모델 뿐만 아니라 환경 모델도 그 모델링 품질에 공을 들여야 한다.</p>

<h2 id="검증">검증</h2>

<p>두 번째 단계는 검증이다.
앞에서 환경 모델이 본래 기능 외에도 부가적으로 복잡하게 들어있는 이유는 바로 이 검증 때문이다. 단 여기서 주의할 게, 검증을 위해 부가적으로 들어간 것이 원래 모델의 동작에 영향이 있으면 안된다.</p>

<p>다음은 이번 예시에서의 검증 항목들이다.</p>

<p><img src="/blog/assets/post/17-07-24-UPPAAL2PLC/verification.png" alt="Verification" /></p>

<p>첫 번째는 일반적으로 데드락을 검증하는 것이다.
두 번째는 보행자의 응답성을 검증한 것인데 보행자 모델을 보면 <code class="highlighter-rouge">push</code> 채널을 통해 버튼 누름을 인지하면 <code class="highlighter-rouge">Waiting</code> 상태로 전이하면서 Clock <code class="highlighter-rouge">waiting_green_light</code>의 값을 <code class="highlighter-rouge">0</code>으로 초기화한다. 이후 신호등으로부터 초록 불 신호를 받으면 <code class="highlighter-rouge">Waiting</code> 상태를 벗어난다. 즉, <code class="highlighter-rouge">Waiting</code> 상태에서의 Clock <code class="highlighter-rouge">waiting_green_light</code>의 최댓값은 보행자 응답 시간의 최대를 나타내며 이 값이 <code class="highlighter-rouge">WAIT_TIME</code>에 2번의 주기 시간을 더한 값을 넘지 않음을 보인다.
세 번째 항목은 신호등이 빨간 불 상태에 진입했을 때 어떤 경우에도 최소한 이를 <code class="highlighter-rouge">WAIT_TIME</code> 시간 동안 유지함을 검증한 것이다. 이 역시 <code class="highlighter-rouge">Green</code> 상태로 전이할 때 초기화되는 Clock <code class="highlighter-rouge">keep_red_light</code>의 값을 통해 확인이 가능하다.</p>

<h2 id="설정-파일">설정 파일</h2>

<p>이로써 검증이 모두 완료되면 UPPAAL2PLC의 입력 파일 하나가 준비된 것이다. 남은 입력 파일인 설정 파일은 간단하다. 그냥 몇 가지 제시되어야 할 설정 값들을 형식에 맞게 입력하면 된다.
다음은 이번 예시에서 사용한 설정 파일의 내용이다.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;platform&gt;</span>
    <span class="nt">&lt;os&gt;</span>linux<span class="nt">&lt;/os&gt;</span>
    <span class="nt">&lt;protocol&gt;</span>soem<span class="nt">&lt;/protocol&gt;</span>
    <span class="nt">&lt;period&gt;</span>10000000<span class="nt">&lt;/period&gt;</span>
<span class="nt">&lt;/platform&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;task</span> <span class="na">type=</span><span class="s">"Controller"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;io</span> <span class="na">varname=</span><span class="s">"pButton"</span> <span class="na">address=</span><span class="s">"1:0x6000:0x1"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">direction=</span><span class="s">"in"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;io</span> <span class="na">varname=</span><span class="s">"pLight"</span> <span class="na">address=</span><span class="s">"1:0x7010:0x1"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">direction=</span><span class="s">"out"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/configuration&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">os</code>와 <code class="highlighter-rouge">protocol</code> 항목의 값은 각각 PLC의 운영체제와 통신 프로토콜의 종류를 나타낸다. 이 값에 따라 UPPAAL2PLC의 resources 디렉토리 아래에 있는 플랫폼 관련 코드들이 응용 생성시에 동적으로 선택되어 컴파일된다.
<code class="highlighter-rouge">period</code> 항목은 PLC 시스템의 제어 주기를 설정하는 것으로 ns 단위로 입력하면 된다.</p>

<p><code class="highlighter-rouge">task</code> 항목은 UPPAAL 프로젝트에 선언된 여러 템플릿들 중 프로그램 모델을 명시하는 것으로, 여기서는 프로그램 모델의 템플릿 이름인 <code class="highlighter-rouge">"Controller"</code>를 값으로 주었다. 아직 UPPAAL2PLC에서는 다중 태스크를 지원하지 않기 때문에 <code class="highlighter-rouge">task</code> 태그는 한 번만 선언 가능하다.
<code class="highlighter-rouge">io</code> 항목은 UPPAAL 모델에 선언된 변수를 실제 통신 변수에 매핑하기 위한 정보다. <code class="highlighter-rouge">varname</code>에는 UPPAAL 모델에 선언된 프로그램쪽 변수를 입력하면 되고, <code class="highlighter-rouge">address</code>에는 통신 변수를 특정하기 위해 통신 프로토콜별로 정의된 포맷에 따라 적으면 된다. 여기서는 SOEM 즉, EtherCAT을 사용하는데 이 프로토콜에서 <code class="highlighter-rouge">address</code>는 “:”으로 구분되는 각 세 파트에 [Slave 번호]:[OD Index]:[OD Subindex]를 적어넣으면 된다. 위 예시에서는 이들이 각각 스위치와 LED 장치를 나타낸다. <code class="highlighter-rouge">type</code>과 <code class="highlighter-rouge">direction</code>에는 각각 그 변수의 타입, 입출력 방향을 입력하면 된다.</p>

<h2 id="데모">데모</h2>

<p>이제 모든 입력 파일이 완성되었으니 UPPAAL2PLC를 실행하면 된다. github에 올린 프로젝트 내에는 위에서 언급한 모든 입력 파일이 준비되어 있으니, github에서 바로 다운받았다면, 명령어를 다음과 같이 입력하면 된다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./Uppaal2PLC.py examples/TrafficLightControl/TrafficLightControl.xml examples/TrafficLightControl/config.xml</code></pre></figure>

<p>이제 생성된 응용 “PlcApp”을 실행해 볼 차례다.
<a href="https://lklab.github.io/blog/blog/Raspberry-Pi-EtherCAT/">지난 번 글</a>에서처럼 라즈베리파이를 EtherCAT 마스터로, EL9800을 EtherCAT 슬레이브로 채택하였다.</p>

<iframe class="video" src="https://www.youtube.com/embed/4VELOOvaF1w" allowfullscreen="" frameborder="0"></iframe>]]></content><author><name>khlee</name></author><category term="MDD" /><summary type="html"><![CDATA[소개]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-24-UPPAAL2PLC/system_model.png" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-24-UPPAAL2PLC/system_model.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SOEM을 활용하여 라즈베리파이를 EtherCAT 마스터로 만들기</title><link href="http://localhost:4000/blog/Raspberry-Pi-EtherCAT/" rel="alternate" type="text/html" title="SOEM을 활용하여 라즈베리파이를 EtherCAT 마스터로 만들기" /><published>2017-07-17T00:00:00+09:00</published><updated>2017-07-17T00:00:00+09:00</updated><id>http://localhost:4000/blog/Raspberry-Pi-EtherCAT</id><content type="html" xml:base="http://localhost:4000/blog/Raspberry-Pi-EtherCAT/"><![CDATA[<p>라즈베리파이에 SOEM을 설치하여 EtherCAT 마스터로 동작하도록 할 것이다.
라즈베리파이는 B+ 모델을 사용했으며, OS로 2017년 03월 02일 버전 raspbian-jessie를 사용했다.</p>

<h2 id="준비하기">준비하기</h2>

<p>먼저 최신 버전의 SOEM을 다운로드 받는다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git clone https://github.com/OpenEtherCATsociety/SOEM</code></pre></figure>

<p><a href="http://openethercatsociety.github.io/">http://openethercatsociety.github.io/</a> 에서 받을 수 있는 1.3.1 버전에서는 make 기반으로 빌드가 가능했었는데, git에서 받은 버전은 cmake 기반으로 빌드를 한다.</p>

<p>사용하는 라즈베리파이에는 cmake가 설치되어있지 않으니 현재 최신 릴리즈 버전인 3.8.2 버전으로 설치했다. [<a href="https://cmake.org/install/">참고</a>]</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget https://cmake.org/files/v3.8/cmake-3.8.2.tar.gz
<span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xvzf</span> cmake-3.8.2.tar.gz
<span class="nv">$ </span><span class="nb">cd </span>cmake-3.8.2/
<span class="nv">$ </span>./bootstrap
<span class="nv">$ </span>make
<span class="nv">$ </span>make <span class="nb">install</span></code></pre></figure>

<p>라즈베리파이가 구닥다리라 엄청 오래 걸렸다..</p>

<p>이제 <a href="https://github.com/OpenEtherCATsociety/SOEM">README.md</a>에 나와있는 방법대로 SOEM 빌드를 한다!</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd </span>SOEM
<span class="nv">$ </span><span class="nb">mkdir </span>build
<span class="nv">$ </span><span class="nb">cd </span>build
<span class="nv">$ </span>cmake ..
<span class="nv">$ </span>make</code></pre></figure>

<p>빌드하고 나면 몇 가지 예제 프로그램이 생성되는데 그 중 SOEM/build/test/linux/simple_test/ 경로에 있는 simple_test라는 프로그램을 실행할 것이다.</p>

<p>그 전에 하드웨어 세팅을 시작하자.
구닥다리 라즈베리파이 B+에는 wifi가 기본 내장되어있지 않아서 ssh를 쓰기 위해 wifi 동글을 사용했다. 따라서 네트워크 인터페이스가 wlan0, eth0 두 개가 되는데, wlan0은 ssh를 포함한 인터넷을, eth0은 EtherCAT 포트로 사용한다.</p>

<p>EtherCAT 슬레이브로 사용할 장치는 Beckhoff사의 EL9800 보드로 하였다.
EtherCAT을 통해 제어 가능한 각 8개의 On-board LED와 스위치가 있다.</p>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" alt="Beckhoff EL9800" /></p>

<p>이제 예제 프로그램을 실행한다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd test</span>/linux/simple_test/
<span class="nv">$ </span>./simple_test eth0</code></pre></figure>

<p>실행시키면 다음 그림과 같이 PDO 값에 대해 모니터링해 준다.</p>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/pdo.png" alt="pdo" /></p>

<p><code class="highlighter-rouge">O:</code> 뒤에 첫 1바이트가 LED를 의미하고, <code class="highlighter-rouge">I:</code> 뒤의 첫 1바이트가 스위치를 의미한다.</p>

<h2 id="제어-프로그램-만들기">제어 프로그램 만들기</h2>

<p>그냥 실행만 시키면 재미없으니 LED에 불을 켜 보자!</p>

<p>SOEM/test/linux/simple_test/simple_test.c 파일을 열어서 PDO 교환을 수행하는 다음 코드를 보면</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* cyclic loop */</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ec_send_processdata</span><span class="p">();</span>
    <span class="n">wkc</span> <span class="o">=</span> <span class="n">ec_receive_processdata</span><span class="p">(</span><span class="n">EC_TIMEOUTRET</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">wkc</span> <span class="o">&gt;=</span> <span class="n">expectedWKC</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Processdata cycle %4d, WKC %d , O:"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">wkc</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oloop</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" %2.2x"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outputs</span> <span class="o">+</span> <span class="n">j</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">" I:"</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">iloop</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" %2.2x"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">j</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">" T:%"</span><span class="n">PRId64</span><span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">,</span><span class="n">ec_DCtime</span><span class="p">);</span>
        <span class="n">needlf</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">osal_usleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">ec_slave[0].outputs + offset</code>이 출력(마스터 -&gt; 슬레이브) PDO, 그러니까 RxPDO를 의미하고 <code class="highlighter-rouge">ec_slave[0].inputs + offset</code>이 TxPDO를 의미한다.</p>

<p>LED는 RxPDO의 첫 번째 바이트로 다음 변수를 통해 접근할 수 있다.</p>

<p><code class="highlighter-rouge">ec_slave[0].outputs + 0</code></p>

<p>정확한 내 장치의 SII에 저장된 PDO 목록을 보고싶다면 같이 빌드되는 예제 프로그램인 slaveinfo를 실행해보면 안다. 다음 명령어를 실행하면</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./slaveinfo eth0 <span class="nt">-map</span></code></pre></figure>

<p><img src="/blog/assets/post/17-07-17-EtherCAT/slaveinfo.png" alt="pdo" /></p>

<p>슬레이브의 SII에 저장된 PDO 매핑 정보가 출력되어 나온다.</p>

<p>다시 LED를 제어하는 것으로 돌아와서!
위 코드의 <code class="highlighter-rouge">for</code> 블록문 첫 번째에 다음 코드를 넣었다.
물론 함수의 첫 부분에 int형 <code class="highlighter-rouge">ledval</code>(초기값 0x1)과 <code class="highlighter-rouge">tick</code> 변수(초기값 0x0)를 선언하였다.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* cyclic loop */</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* for LED output test */</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">tick</span> <span class="o">%</span> <span class="mi">50</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">ledval</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ledval</span> <span class="o">&gt;=</span> <span class="mh">0x100</span><span class="p">)</span>
            <span class="n">ledval</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
        <span class="o">*</span><span class="p">(</span><span class="n">ec_slave</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outputs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ledval</span><span class="p">;</span>
        <span class="n">tick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* for LED output test */</span>
    <span class="n">ec_send_processdata</span><span class="p">();</span>
    <span class="n">wkc</span> <span class="o">=</span> <span class="n">ec_receive_processdata</span><span class="p">(</span><span class="n">EC_TIMEOUTRET</span><span class="p">);</span></code></pre></figure>

<p>이제 다시 build 디렉토리로 돌아와서 빌드한다.
다시 빌드할 때에는 make만 하면 된다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ../../../build/
<span class="nv">$ </span>make</code></pre></figure>

<p>이제 실행시켜보면 된다.</p>

<iframe class="video" src="https://www.youtube.com/embed/CrT6T_HWt78" allowfullscreen="" frameborder="0"></iframe>]]></content><author><name>khlee</name></author><category term="EtherCAT" /><summary type="html"><![CDATA[라즈베리파이에 SOEM을 설치하여 EtherCAT 마스터로 동작하도록 할 것이다. 라즈베리파이는 B+ 모델을 사용했으며, OS로 2017년 03월 02일 버전 raspbian-jessie를 사용했다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" /><media:content medium="image" url="http://localhost:4000/assets/post/17-07-17-EtherCAT/20170529_143851.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>